## 가상 메모리

가상 메모리는 **물리 메모리 크기의 제약을 받지 않고 프로그램을 실행할 수 있도록 하는 기술**이다.

프로세스는 실제 물리 메모리보다 큰 논리 주소 공간을 사용할 수 있다.

- 각 프로세스는 독립적인 논리 주소 공간을 가짐
- 실제로 필요한 부분만 물리 메모리에 저장하고 나머지는 디스크에 저장

<br>

### 1. 논리 주소와 물리 주소

- **논리 주소(Virtual Address)**
    - 각 프로세스마다 0번지부터 시작
    - 프로세스는 자신만의 연속된 주소 공간을 가진 것처럼 인식
- **물리 주소(Physical Address)**
    - 실제 메모리의 주소
    - 여러 프로세스가 공유
- 주소 변환
    - **MMU** 사용

<br>

**MMU**(Memory Management Unit) 

- 논리 주소를 물리 주소로 변환하는 하드웨어
- **Base Register**(재배치 레지스터): 시작 물리 주소 저장
- **Limit Register**: 프로세스 메모리 크기 저장 (보호 목적)
    - CPU가 요청한 논리 주소 값이 저장된 값 이내인지 검사
- 물리 주소 = 논리 주소 + Base Register

<br>

### 2. 페이징 시스템

- **페이지 :** 논리 메모리를 고정 크기로 나눈 블록
- **프레임** : 물리 메모리를 페이지와 같은 크기로 나눈 블록
- **페이지 테이블** : 페이지 번호를 프레임 번호로 변환하는 자료구조
    - 각 프로세스마다 독립적인 페이지 테이블 보유
    - **페이지 테이블 엔트리 구성 요소**
        - **프레임 번호**: 해당 페이지가 적재된 물리 메모리 위치
        - **유효 비트(Valid Bit)**: 페이지가 메모리에 있는지 여부 (1: 메모리, 0: 디스크)
        - **참조 비트(Reference Bit)**: 최근 접근 여부
        - **수정 비트(Dirty Bit)**: 페이지 내용이 수정되었는지 여부
        - **보호 비트(Protection Bit)**: 읽기/쓰기/실행 권한
- **페이징**
    - 물리 메모리를 **프레임**, 논리 메모리를 페이지로 고정 크기 분할
    - 페이지를 비연속적인 프레임에 할당
    - **페이지 테이블**로 페이지 번호 → 프레임 번호 매핑
    - 외부 단편화 해결
    - 프로세스의 마지막 페이지가 페이지 크기보다 작을 경우 남은 공간이 낭비되어 **내부 단편화 발생 가능**
        
        <img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/operating-system/unit11/image1.png" width="100%">
        
- **주소 변환 과정**
    1. CPU가 논리 주소 생성(페이지 번호 + 오프셋)
    2. MMU가 페이지 테이블에서 페이지 번호 탐색
    3. 해당 프레임 번호 획득
    4. 프레임 번호 + 오프셋 = 물리 주소
    5. 물리 메모리 접근

<br>

### 3. TLB

페이지 테이블의 일부를 캐싱하는 고속 하드웨어로 최근에 사용된 페이지 변환 정보를 저장한다.

CPU가 논리 주소를 생성하면 TLB에서 해당 페이지 번호를 검색한다.

- **TLB Hit**: TLB에서 프레임 번호를 찾아 즉시 물리 주소 생성 (빠름)
- **TLB Miss**: TLB에 없으면 페이지 테이블에서 찾아서 TLB 업데이트 (느림)

<br>

### 4. 요구 페이징

프로그램 실행 시 필요한 페이지만 메모리에 저장하는 기법

모든 페이지를 저장하는 것이 아닌 실제 접근이 발생할 때만 해당 페이지를 저장한다.

- 유효 비트로 메모리에 저장 여부 표시
- 메모리 사용량 감소
- 프로세스 시작 시간 단축

<br>

### 5. 페이지 폴트

프로세스가 접근하려는 페이지가 물리 메모리에 없을 때 발생하는 예외 상황으로 유효 비트가 0일 때 발생한다.

- 처리 과정
    1. CPU가 유효 비트가 0인 페이지에 접근을 시도하면 trap 발생
    2. 운영체제가 요구된 페이지를 디스크에서 탐색
    3. 탐색된 페이지를 물리 메모리의 비어있는 프레임에 로드
    4. 페이지 테이블 갱신
    5. 중단된 CPU 재시작
    
    ⚠️ 빈 프레임이 없다면 페이지 교체 알고리즘 실행
    
<br>

### 6. 세그먼테이션

- 프로그램을 논리적 단위(코드, 데이터, 스택 등)인 세그먼트로 분할
- 각 세그먼트를 독립적으로 할당
- 세그먼트 테이블로 세그먼트 번호 → 시작 주소, 크기 매핑
- 내부 단편화 해결
- 서로 다른 크기의 세그먼트의 할당&해제가 반복되면 공간들이 조각으로 나누어져 외부 단편화 발생 가능
    
    <img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/operating-system/unit11/image2.png" width="100%">