## 페이지 관리

가상 메모리 환경에서 페이지를 효율적으로 사용하기 위해 **할당, 교체 방식과 페이지 테이블을 관리**한다.

<br>

### 1. 페이지 교체 알고리즘

메모리가 가득 찼을 때 **어떤 페이지를 제거할지 결정**하는 알고리즘이다.

**FIFO (First-In-First-Out)**

- **가장 먼저 들어온** 페이지 교체
- 구현 간단
- **Belady's Anomaly**: 프레임 수 증가 시 페이지 폴트 증가 가능

**OPT (Optimal)**

- **앞으로 가장 오랫동안 사용되지 않을** 페이지 교체
- **이론적 최적해** (실제 구현 불가능 - 미래 예측 필요)
- 다른 알고리즘 성능 비교 기준

**LRU (Least Recently Used)**

- **가장 오랫동안 사용되지 않은** 페이지 교체
- **최근 사용 기록으로 미래 예측** (시간 지역성 활용)
- 구현: 타임스탬프, 스택, 카운터
- 실용적이고 효율적

**LFU (Least Frequently Used)**

- **참조 횟수가 가장 적은** 페이지 교체
- 초기 집중 사용 후 미사용 페이지가 남을 수 있음

**Clock (Second Chance)**

- **FIFO + 유효 비트** 활용
- **순환 리스트** 형태, 포인터가 순회하며 참조 비트 확인
- 참조 비트 = **1 → 0**으로 변경 후 다음 페이지로 이동
- 참조 비트 = 0 → **해당 페이지 교체**
- **LRU** 근사, 구현 효율적

<br>

### 2. 프레임 할당

프로세스에 **프레임을 어떻게 할당**할 것인지 결정하는 정책

- **균등 할당(Equal Allocation)**
    - 모든 프로세스에 **동일한 프레임 수** 할당
    - 공평하지만 비효율적
- **비례 할당(Proportional Allocation)**
    - **프로세스 크기에 비례**하여 프레임 할당
    - 큰 프로세스에 더 많은 프레임 제공
- **우선순위 할당(Priority Allocation)**
    - **프로세스 우선순위에 따라** 프레임 할당

<br>

### 3. 전역 교체 vs 지역 교체

- **전역 교체** : **모든 프로세스의 페이지** 중에서 교체 대상 선택
    - 장점 : 프로세스 별 프레임 할당량 조절
    - 단점 : 페이지 폴트 발생률 조절 불가
- **지역 교체** : 각 프로세스가 **자신의 프레임 내에서만** 교체
    - 장점 : 프로세스 간 간섭 없음
    - 단점 : 메모리 효율성 떨어짐

<br>

### 4. 스레싱

- **페이지 폴트가 과도하게 발생**하여 CPU 이용률이 급격히 낮아지는 현상
- 원인 : 프로세스들에게 **할당된 프레임이 부족**
- 해결 방법
    - **Working Set Model** : 최근 일정 시간 동안 참조한 페이지 집합 유지
    - **Page Fault Frequency (PFF)** : 페이지 폴트 비율 모니터링하여 프레임 조정
    - 다중 프로그래밍 수준 감소 (프로세스 일시 중지)

<br>

### 5. **계층적 페이징 (Hierarchical Paging)**

페이지 테이블이 너무 클 때 **페이지 테이블을 여러 단계로 분할**한다.

**필요성**

- 32비트 시스템, 4KB 페이지 사용 시 :
    - 페이지 개수 = $2^{20}$개 (약 100만 개)
    - 페이지 테이블 크기 = $2^{20}$× 4바이트 = **4MB**
    - 모든 프로세스마다 **4MB 필요 → 메모리 낭비❗️**

**2단계 페이지 테이블**

- 페이지 테이블을 다시 페이징
    - **1단계(페이지 디렉토리)** : 2단계 페이지 테이블 주소 저장
    - **2단계** : 실제 프레임 번호 저장
    - 사용하지 않는 주소 공간의 **2단계 테이블은 생성하지 않음**

**주소 구조**

- 논리 주소 = p1(10비트) + p2(10비트) + 오프셋(12비트)

**메모리 절약**

- ex) 12MB 프로세스 (하위 8MB + 상위 4MB 사용)
    - 필요한 테이블 : 1단계 4KB + 2단계 3개*4KB = 16KB
    - 단일 테이블 대비 250배 절약

**단점**

- 메모리 접근 횟수 증가
    - TLB 사용으로 완화

<img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/operating-system/unit12/image1.png" width="100%">

<br>

### 6. Copy-on-Write (COW)

- 프로세스 생성 시 **부모와 자식이 처음에는 동일한 페이지 공유**
- **페이지가 수정될 때만 복사본 생성**
- **불필요한 복사 방지**로 성능 향상

<br>

### 7. 페이지 크기 결정

- **작은 페이지**
    - **내부 단편화 감소**
    - 페이지 테이블 크기 증가
- **큰 페이지**
    - **페이지 테이블 크기 감소**
    - I/O 효율 증가
    - 내부 단편화 증가
- 최근 시스템: Huge Page 등 가변 페이지 크기 지원
- 일반적으로 4KB 사용