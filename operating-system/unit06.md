# 스레드와 멀티스레딩(Thread & Multithreading)

**스레드**는 프로세스 내에서 실행되는 **흐름의 단위**이며, 하나의 프로세스는 여러 개의 스레드를 가질 수 있다. **멀티스레딩**은 하나의 프로세스 내에서 여러 스레드가 동시에 실행되어 작업을 병렬로 처리하는 기법이다.

<br>

### 1. 스레드의 개념

#### **1-1. 프로세스 vs 스레드**

| **구분** | **프로세스** | **스레드** |
| --- | --- | --- |
| **정의** | 실행 중인 프로그램 | 프로세스 내 실행 흐름 |
| **자원** | 독립적인 메모리 공간 | 프로세스 자원 공유 |
| **생성 비용** | 높음 (메모리 할당) | 낮음 (스택만 할당) |
| **문맥 교환** | 느림 (전체 컨텍스트) | 빠름 (스택/레지스터만) |
| **통신** | IPC 필요 (복잡) | 공유 메모리 (간단) |
| **독립성** | 강함 (다른 프로세스 영향 X) | 약함 (한 스레드 오류가 전체 영향) |

<br>

#### **1-2. 스레드의 구조**

하나의 프로세스는 최소 하나의 메인 스레드를 가지며, 추가 스레드를 생성할 수 있다.

**스레드가 공유하는 자원**
- **Code** (프로그램 코드)
- **Data** (전역 변수, 정적 변수)
- **Heap** (동적 할당 메모리)
- **열린 파일**, **소켓** 등 시스템 자원

**스레드가 독립적으로 가지는 자원**
- **Stack** (지역 변수, 함수 호출 정보)
- **PC** (Program Counter)
- **Registers** (레지스터 값)

**[이미지 필요: 프로세스 메모리 구조]**
- Code, Data, Heap (공유 영역)
- Thread 1/2/3 Stack (독립 영역)

<br>

### 2. 멀티스레딩의 필요성

#### **2-1. 단일 스레드 vs 멀티 스레드**

**단일 스레드**
- 작업을 순차적으로 처리
- 하나의 작업이 끝나야 다음 작업 시작
- I/O 대기 시간 동안 CPU 유휴 상태

**멀티 스레드**
- 여러 작업을 동시에 처리
- I/O 대기 중에도 다른 작업 수행
- CPU 활용률 향상

<br>

#### **2-2. 멀티스레딩 사용 예시**

**웹 브라우저**
- Thread 1: HTML 파싱
- Thread 2: 이미지 다운로드
- Thread 3: JavaScript 실행
- Thread 4: 사용자 입력 처리

**웹 서버**
- Main Thread: 클라이언트 요청 수신
- Worker Thread 1~N: 각 요청 병렬 처리

<br>

### 3. 병렬성과 동시성

#### **3-1. 병렬성 (Parallelism)**

**여러 코어에서 실제로 동시에 실행**

**4코어 CPU에서 병렬 실행**
- Core 1: Thread A
- Core 2: Thread B
- Core 3: Thread C
- Core 4: Thread D

→ 정말로 동시에 실행 중

<br>

#### **3-2. 동시성 (Concurrency)**

**빠른 전환으로 동시에 실행되는 것처럼 보임**

**1코어 CPU에서 동시성 실행**
- Core 1이 Thread A, B, C, D를 빠르게 전환하며 실행
- Context Switch를 통해 동시에 실행되는 것처럼 보임

<br>

#### **3-3. 하이퍼스레딩 (Hyper-Threading)**

1개의 물리 코어가 2개의 논리 코어처럼 동작

**4코어 8스레드 CPU**
- 물리 코어 4개
- 논리 코어 8개
- 최대 8개 스레드 동시 실행 가능

<br>

### 4. 스레드 동기화 문제

#### **4-1. 경쟁 조건 (Race Condition)**

여러 스레드가 동시에 공유 자원에 접근할 때 발생하는 문제

**문제 발생 원인**

`counter++` 연산은 실제로 3단계로 이루어짐:
1. `temp = counter` (메모리에서 읽기)
2. `temp = temp + 1` (연산)
3. `counter = temp` (메모리에 쓰기)

Thread 1과 Thread 2가 동시에 이 작업을 수행하면:
- Thread 1: counter를 0으로 읽음
- Thread 2: counter를 0으로 읽음 (Thread 1이 쓰기 전)
- Thread 1: counter에 1을 씀
- Thread 2: counter에 1을 씀
- 결과: 2번 증가했지만 값은 1 (1회 손실)

<br>

#### **4-2. 뮤텍스 (Mutex)**

**Mutual Exclusion** (상호 배제): 한 번에 하나의 스레드만 접근 가능

**동작 방식**
1. `lock()`: 임계 영역 진입 전 잠금
2. 임계 영역: 공유 자원 접근
3. `unlock()`: 임계 영역 탈출 후 해제

**특징**
- 이진 세마포어 (0 또는 1)
- 소유권 개념: 잠근 스레드만 해제 가능

<br>

#### **4-3. 세마포어 (Semaphore)**

여러 스레드가 제한된 수만큼 동시 접근 가능

**동작 방식**
- `wait()` (P 연산): 세마포어 값 감소, 0이면 대기
- `signal()` (V 연산): 세마포어 값 증가

**예시: 데이터베이스 연결 풀**
- 세마포어 값 = 5 (최대 5개 연결)
- 5개 스레드가 연결 사용 중이면 6번째 스레드는 대기
- 하나가 반환되면 대기 중인 스레드 실행

<br>

#### **4-4. Mutex vs Semaphore**

| **구분** | **Mutex** | **Semaphore** |
| --- | --- | --- |
| **동시 접근** | 1개 스레드만 | N개 스레드 |
| **소유권** | 잠금한 스레드만 해제 가능 | 아무 스레드나 해제 가능 |
| **용도** | 임계 영역 보호 | 자원 개수 제한 |
| **예시** | 공유 변수 접근 | 데이터베이스 연결 풀 |

<br>

### 5. 교착 상태 (Deadlock)

두 개 이상의 스레드가 서로 상대방이 가진 자원을 기다리며 무한정 대기하는 상태

**교착 상태 예시**
- Thread 1: mutex1 획득 → mutex2 대기
- Thread 2: mutex2 획득 → mutex1 대기
- 결과: 두 스레드 모두 무한 대기

<br>

**교착 상태 발생 조건 (4가지 모두 만족 시)**

1. **상호 배제 (Mutual Exclusion)**: 한 번에 하나의 스레드만 자원 사용
2. **점유와 대기 (Hold and Wait)**: 자원을 가진 채 다른 자원 대기
3. **비선점 (No Preemption)**: 강제로 자원을 빼앗을 수 없음
4. **순환 대기 (Circular Wait)**: 자원 대기가 순환 구조

<br>

**교착 상태 해결 방법**

**1) 자원 획득 순서 통일**
- 모든 스레드가 동일한 순서로 자원 획득
- 예: 항상 mutex1 → mutex2 순서

**2) 타임아웃 설정**
- 일정 시간 대기 후 획득 실패 시 보유 자원 반환

**3) 교착 상태 감지 및 회복**
- 주기적으로 교착 상태 확인
- 발견 시 일부 스레드 강제 종료

**4) 은행원 알고리즘**
- 안전한 상태에서만 자원 할당

<br>

### 6. 스레드 풀 (Thread Pool)

스레드를 미리 생성해두고 재사용하는 패턴

**스레드 풀의 동작**
1. 고정된 개수의 스레드를 미리 생성
2. 작업 큐에 작업 추가
3. 유휴 스레드가 작업 큐에서 작업을 가져와 실행
4. 작업 완료 후 스레드는 다시 유휴 상태로 대기

**스레드 풀의 장점**
- 스레드 생성/제거 오버헤드 감소
- 동시 실행 스레드 수 제한 가능 (자원 관리)
- 작업 큐를 통한 효율적인 관리

<br>

### 7. 멀티프로세스 vs 멀티스레드

| **구분** | **멀티프로세스** | **멀티스레드** |
| --- | --- | --- |
| **안정성** | 높음 (독립적 실행) | 낮음 (한 스레드 오류 → 전체 영향) |
| **자원 효율** | 낮음 (메모리 중복) | 높음 (자원 공유) |
| **생성 속도** | 느림 | 빠름 |
| **통신** | IPC (복잡) | 공유 메모리 (간단) |
| **문맥 교환** | 느림 | 빠름 |
| **적합한 경우** | 안정성 중요, 독립 작업 | 빠른 응답, 자원 공유 필요 |

<br>

**선택 기준**

**멀티프로세스 사용**
- 안정성이 최우선 (크롬 브라우저 탭)
- 완전히 독립적인 작업
- 서로 다른 프로그램 실행

**멀티스레드 사용**
- 빠른 응답 속도 필요 (GUI 프로그램)
- 자원 공유 필요 (웹 서버)
- 가벼운 작업 분산

<br>

### 8. 스레드 수와 성능

**스레드를 많이 쓸수록 항상 성능이 좋아질까?** ❌

**문제점**
- 스레드가 많아지면 컨텍스트 스위칭 오버헤드 증가
- 메모리 사용량 증가 (각 스레드마다 스택 할당)
- 동기화 복잡도 증가

**적정 스레드 수 계산**
- **CPU 집약적 작업**: 스레드 수 = CPU 코어 수
- **I/O 집약적 작업**: 스레드 수 = CPU 코어 수 × 2 ~ 4

<br>
