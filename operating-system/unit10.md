## 메모리 관리 기초

운영체제는 프로그램의 실행을 위해 다양한 메모리 공간을 제공하고 효율적으로 할당하고 회수할 수 있도록 관리한다.

<br>

### 1. 메모리 계층 구조

| 계층 | 속도 | 용량 | 특징 |
| --- | --- | --- | --- |
| 레지스터 | 가장 빠름 | 매우 작음 | CPU 내부 |
| 캐시 | 매우 빠름 | 작음 | L1, L2, L3 캐시 |
| 주기억장치(RAM) | 빠름 | 중간 | 휘발성 |
| 보조기억장치 | 느림 | 큼 | 비휘발성 |

<br>

### 2. 프로세스 메모리 구조

프로세스가 실행될 때 메모리는 다음과 같은 영역으로 구성된다.

**코드 영역**

- 실행할 프로그램의 코드가 저장
- 기계어 형태로 저장
- CPU는 저장된 명령어를 실행

**데이터 영역**

- **전역 변수와 정적 변수** 저장
- 프로그램 시작과 동시에 할당되며 종료 시까지 유지

**힙 영역**

- 동적 메모리 할당 영역
- 사용자에 의해 **동적으로** 할당&해제 (malloc, free 등)
- 낮은 주소 → 높은 주소 방향 증가
- 할당된 메모리를 해제하지 않으면 계속 유지 (memory leak 발생)
- 유일하게 **런타임** 시 크기가 결정

**스택 영역**

- **지역 변수와 매개 변수** 저장
- 함수 호출 완료 시 메모리 해제됨
- 높은 주소 → 낮은 주소 방향 증가

<br>

### 3. 주소 바인딩

프로그램의 **논리 주소**를 **물리 주소**로 변환하는 과정

- **컴파일 타임**: 컴파일 시 물리 주소 결정
    - 물리 주소를 변경하고 싶으면 다시 컴파일해야 함
- **로드 타임**: 프로그램 로딩 시 주소 결정
- **실행 타임**: 실행 중 주소 변환 (가장 유연, MMU 사용)

<br>

### 4. 메모리 할당 방식

**연속 할당 :** 프로세스가 메모리의 연속된 공간을 차지

- **고정 분할(Fixed Partitioning)**: 메모리를 고정 크기로 분할
    - 내부 단편화(Internal Fragmentation) 발생: 할당된 공간 > 실제 사용 공간
- **가변 분할(Dynamic Partitioning)**: 프로세스 크기에 맞춰 동적 할당
    - 외부 단편화(External Fragmentation) 발생: 총 여유 공간은 충분하나 연속되지 않음

**배치 전략**

- **First Fit**: 첫 번째 적합한 공간에 할당 (빠름)
- **Best Fit**: 가장 작은 적합한 공간에 할당 (공간 효율적, 탐색 느림)
- **Worst Fit**: 가장 큰 공간에 할당 (큰 빈 공간 유지)

<br>

### 5. 단편화

**내부 단편화 :** 필요한 크기보다 더 큰 메모리가 할당되어서 공간이 낭비되는 현상

<img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/operating-system/unit10/image1.png" width="100%">

**외부 단편화** : 남아있는 메모리 크기는 충분하나 실제로는 할당할 수 없는 현상

<img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/operating-system/unit10/image2.png" width="100%">

**단편화 해결 방법**

- **압축 (Compaction)**
    - 흩어진 빈 공간들을 한곳으로 모음
    - 외부 단편화 해결
    - 오버헤드가 크고 프로세스 이동 필요
- **페이징 (Paging) :** 메모리를 고정 크기(페이지/프레임)로 나누어 비연속 할당, 외부 단편화 해결
- **세그먼테이션 (Segmentation) :** 프로그램을 논리적 단위(코드, 데이터, 스택 등)로 분할하여 할당, 내부 단편화 해결

<br>

### 6. 스와핑 (Swapping)

- 메모리 부족 시 프로세스를 **디스크(Swap Space)**로 이동
- 나중에 다시 메모리로 로드
- 느린 디스크 I/O로 인한 오버헤드