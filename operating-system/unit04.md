# 인터럽트(Interrupt)

**인터럽트**는 CPU가 프로그램을 실행하는 도중 **예기치 않은 상황**이나 **우선순위가 높은 작업**이 발생했을 때, 현재 작업을 중단하고 해당 상황을 처리한 후 다시 원래 작업으로 돌아가는 메커니즘이다. 이는 CPU 효율성을 극대화하고 입출력 장치와의 비동기 통신을 가능하게 한다.

<br>

### 1. 인터럽트의 필요성

입출력(I/O) 작업은 CPU 연산보다 수천~수만 배 느리다. 만약 CPU가 I/O 작업이 완료될 때까지 기다린다면, 고가의 CPU 자원이 낭비된다.

**인터럽트의 핵심 목적**
- CPU 유휴 시간 최소화 (CPU 이용률 극대화)
- 비동기 이벤트 처리 (I/O 완료, 타이머, 하드웨어 오류)
- 우선순위가 높은 작업의 즉각 처리

<br>

### 2. 인터럽트의 종류

인터럽트는 크게 하드웨어 인터럽트와 소프트웨어 인터럽트로 분류된다.

<br>

#### **2-1. 하드웨어 인터럽트 (Hardware Interrupt)**

외부 하드웨어 장치가 CPU에 신호를 보내 발생시키는 인터럽트

**하드웨어 인터럽트의 종류**

| **인터럽트** | **발생 원인** | **예시** |
| --- | --- | --- |
| **I/O 인터럽트** | 입출력 작업 완료 | 디스크 읽기 완료, 네트워크 패킷 도착 |
| **타이머 인터럽트** | 타이머 만료 | Time slice 종료, 스케줄링 |
| **전원 인터럽트** | 전원 이상 | 정전, 전압 불안정 |
| **기계 고장 인터럽트** | 하드웨어 오류 | 메모리 오류, CPU 과열 |
| **외부 신호 인터럽트** | 외부 장치 신호 | 키보드, 마우스 입력 |

<br>

**하드웨어 인터럽트 분류**

**1) 마스커블 인터럽트 (Maskable Interrupt)**
- CPU가 무시할 수 있는 인터럽트
- 인터럽트 마스크 레지스터로 비활성화 가능
- 대부분의 I/O 인터럽트가 해당

**2) 논마스커블 인터럽트 (Non-Maskable Interrupt, NMI)**
- CPU가 절대 무시할 수 없는 인터럽트
- 치명적인 하드웨어 오류 처리
- 예: 메모리 패리티 에러, 전원 장애

<br>

#### **2-2. 소프트웨어 인터럽트 (Software Interrupt)**

프로그램 실행 중 명령어에 의해 발생하는 인터럽트. **트랩(Trap)** 또는 **예외(Exception)**라고도 한다.

**소프트웨어 인터럽트의 종류**

| **종류** | **발생 원인** | **예시** |
| --- | --- | --- |
| **시스템 콜** | 프로그램의 의도적 요청 | read(), write(), fork() |
| **예외 (Exception)** | 프로그램 오류 | Division by zero, Segmentation fault |
| **트랩 (Trap)** | 디버깅, 브레이크포인트 | Breakpoint, Single step |

<br>

### 3. 인터럽트 동작 과정
```
1. 프로세스 A 실행 중
2. 인터럽트 발생 (I/O 완료, 타이머 등)
3. 현재 명령어 완료
4. CPU가 인터럽트 라인 확인
5. 현재 상태를 PCB에 저장 (PC, 레지스터 값, 프로세서 상태)
6. 모드 비트 변경 (1 → 0, 커널 모드)
7. 인터럽트 벡터 테이블 조회
8. ISR(Interrupt Service Routine) 실행
9. 저장된 상태 복원
10. 모드 비트 변경 (0 → 1, 사용자 모드)
11. 프로세스 A로 복귀
```

<br>

#### **상세 단계별 설명**

**Step 1. 인터럽트 발생**
- 하드웨어 장치 또는 소프트웨어가 인터럽트 라인 세팅
- CPU는 매 명령 실행 후 인터럽트 라인 검사

**Step 2. 현재 상태 저장**
- PC (다음에 실행할 명령 주소)
- PSW (Processor Status Word)
- 레지스터 값들
- 저장 위치: 프로세스의 PCB (Process Control Block)

**Step 3. 인터럽트 벡터 조회**
- 인터럽트 벡터: 각 인터럽트에 대응하는 ISR의 주소를 담은 테이블
- 인터럽트 종류별로 번호가 할당됨

**Step 4. ISR 실행**
- ISR (Interrupt Service Routine): 인터럽트 핸들러
- 실제 인터럽트 처리 코드
- 예: 디스크 데이터 읽기, 키보드 입력 처리

**Step 5. 복귀**
- IRET (Interrupt Return) 명령어 실행
- 저장했던 상태 복원
- 중단되었던 프로세스로 복귀

<br>

### 4. 인터럽트와 시스템 콜의 관계

시스템 콜은 **소프트웨어 인터럽트**를 통해 구현된다.

**시스템 콜 vs 하드웨어 인터럽트**

| **구분** | **시스템 콜** | **하드웨어 인터럽트** |
| --- | --- | --- |
| **발생 주체** | 프로그램 (의도적) | 하드웨어 장치 |
| **발생 시점** | 동기적 (프로그램 실행 중) | 비동기적 (예측 불가) |
| **목적** | 커널 서비스 요청 | 이벤트 알림 |
| **예시** | fork(), read(), write() | I/O 완료, 타이머 |
| **종류** | 소프트웨어 인터럽트 | 하드웨어 인터럽트 |

<br>

### 5. 인터럽트 우선순위

여러 인터럽트가 동시에 발생하면 우선순위에 따라 처리한다.

#### **우선순위 순서 (일반적)**
```
높음: 전원 장애 (Power Failure)
      기계 고장 (Machine Check)
      타이머 (Timer)
      I/O 완료 (I/O Completion)
낮음: 외부 신호 (External Signal)
```

<br>

#### **인터럽트 우선순위 처리 방법**

**1) 폴링 (Polling)**
- 순차적으로 각 장치의 인터럽트 요청 확인
- 구현 간단하지만 시간 소모

**2) 벡터 인터럽트 (Vectored Interrupt)**
- 인터럽트 발생 장치가 자신의 벡터 번호 전송
- CPU가 즉시 해당 ISR로 점프
- 빠르고 효율적

**3) 인터럽트 네스팅 (Interrupt Nesting)**
- 낮은 우선순위 ISR 실행 중 높은 우선순위 인터럽트 발생 시
- 현재 ISR을 중단하고 높은 우선순위 인터럽트 처리

<br>

### 6. 인터럽트 지연 시간 (Interrupt Latency)

**인터럽트 지연 시간**은 인터럽트 발생부터 ISR 실행 시작까지의 시간이다.

**지연 시간 구성 요소**
- 현재 명령 완료
- 인터럽트 감지
- 상태 저장
- ISR 주소 조회

**지연 시간 최소화 방법**
- 짧은 ISR 작성
- 불필요한 인터럽트 비활성화
- 우선순위 기반 스케줄링
- 하드웨어 버퍼 활용

<br>

### 7. 인터럽트 비활성화

일부 임계 영역(Critical Section)에서는 인터럽트를 일시적으로 비활성화해야 한다.

**주의사항**
- 인터럽트를 너무 오래 비활성화하면 시스템 응답성 저하
- 실시간 시스템에서는 특히 중요
- 최소 시간만 비활성화해야 함

<br>

### 8. 타이머 인터럽트

운영체제는 타이머 인터럽트를 사용하여 프로세스 스케줄링을 구현한다.

**타이머 인터럽트의 역할**
- CPU 시간 분할 (Time Sharing)
- 프로세스 스케줄링
- 시스템 시간 관리
- 타임아웃 처리

<br>

### 9. 인터럽트 vs 폴링

| **구분** | **인터럽트** | **폴링 (Polling)** |
| --- | --- | --- |
| **방식** | 이벤트 발생 시 알림 | 주기적으로 상태 확인 |
| **CPU 효율** | 높음 (필요할 때만 처리) | 낮음 (계속 확인) |
| **응답 속도** | 빠름 | 느림 (폴링 주기에 따라) |
| **오버헤드** | 낮음 | 높음 (계속 확인) |
| **복잡도** | 높음 (ISR 구현 필요) | 낮음 (간단한 루프) |
| **적합한 경우** | 빈도가 낮은 이벤트 | 빈도가 높은 이벤트 |

<br>

### 10. 문맥 교환 (Context Switch)과의 관계

**문맥 교환**은 CPU가 한 프로세스에서 다른 프로세스로 전환하는 과정이다.

**모든 인터럽트가 문맥 교환을 일으키는가?**

아니다!

- **ISR만 실행 후 복귀**: 문맥 교환 없음
- **스케줄러 호출 시**: 문맥 교환 발생
```
[문맥 교환 없는 경우]
Process A 실행 → I/O 인터럽트 → ISR 실행 → Process A 복귀

[문맥 교환 있는 경우]
Process A 실행 → 타이머 인터럽트 → 스케줄러 호출 → Process B 실행
```
