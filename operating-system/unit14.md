## 파일 시스템과 디스크 관리

파일 시스템은 보조기억장치에 파일과 디렉토리를 구조화하여 저장하고 관리한다.

<br>

### 1. 파일

파일은 관련 정보들의 집합에 이름을 붙인 것으로 **논리적인 저장 단위**이다.

- 파일 속성(or 파일 메타데이터)
    - 이름, 타입, 위치, 크기, 소유자, 접근 권한 등
- 파일 연산
    - 생성, 삭제, 열기, 닫기, 쓰기, 읽기, 위치 변경 등
- 접근 방법
    - **순차 접근** : 처음부터 순서대로 읽기/쓰기
    - **직접 접근** : 임의의 순서로 접근
    - **인덱스 접근**: 인덱스를 먼저 찾고, 대응되는 포인터를 얻어 접근

<br>

### 2. 디렉터리

파일의 속성 중 일부를 보관하고 있는 **특수한 파일**이다.

- **1단계 디렉터리**
    - 모든 파일이 하나의 디렉터리에 존재
    - 각각의 파일 이름이 달라야 함
    - 수가 증가하면 관리하기 어려움
        
        <img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/operating-system/unit14/image1.png" width="100%">
        
- **2단계 디렉터리**
    - 각 사용자마다 독립적인 디렉터리
    - 마스터 파일 디렉터리(MFD)가 사용자 파일 디렉터리(UFD)를 관리
    - MFD는 각 사용자의 이름, 계정 번호, UFD를 가리키는 포인터를 가짐
    - UFD는 한 사용자가 소유하는 파일 정보를 가짐, 사용자 파일을 관리
    - 두 파일이 서로 다른 UFD에 속한 경우 동일한 이름 가능
        
        <img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/operating-system/unit14/image2.png" width="100%">
        
- **트리 구조 디렉터리**
    - 하나의 루트 디렉터리와 여러 개의 서브 디렉터리로 구성
    - **절대 경로**: 루트부터의 전체 경로 (/home/user/file.txt)
    - **상대 경로**: 현재 디렉토리 기준 (./file.txt, ../parent/file.txt)
        
        <img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/operating-system/unit14/image3.png" width="100%">
        
- **비순환 그래프 디렉터리**
    - 디렉터리 간 **공유 허용**
    - 공유된 파일을 삭제하면 현재 파일을 가리키는 포인터는 대상이 없어짐
        
        <img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/operating-system/unit14/image4.png" width="100%">
        
- **일반 그래프 디렉터리**
    - **순환을 허용**하는 그래프 구조
    - **가비지 컬렉션**으로 빈 공간을 찾아 정리함
        
        <img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/operating-system/unit14/image5.png" width="100%">
        
<br>        

### 3. 파일 할당

파일 데이터를 디스크에 할당하는 방법 3가지

- **연속 할당** : 파일을 디스크의 **연속된 블록**에 저장
    - 장점 : 순차 접근 빠름, 직접 접근 간단
    - 단점 : 파일 할당과 해제를 반복하면 빈 공간이 생겨 **외부 단편화** 발생, 파일 크기 변경 어려움
- **연결 할당** : **링크드 리스트** 방식으로 블록에 저장
    - 장점 : 외부 단편화 없음
    - 단점 : **직접 접근 불가능**, 중간 포인터가 끊어지면 나머지 접근 불가
        - 해결 방법 : **FAT(File Allocation Table)** 도입
            
            → 모든 포인터를 별도 테이블(FAT)에 모아서 **메모리에 캐싱**
            
- **인덱스 할당** : 각 파일마다 **인덱스 블록**을 가져서 그곳에 모든 데이터 블록의 포인터를 저장
    - 장점 : **직접 접근 가능**, 외부 단편화 없음
    - 단점 : 인덱스 블록 오버헤드, 작은 파일도 인덱스 블록 필요
        - 해결 방법 : 인덱스 블록을 연결 할당, 다단계 인덱스, Combined(연결 + 다단계)

<br>

### 4. 디스크

디스크는 가장 많이 사용하는 보조기억장치 중 하나이며 주기억장치보다 훨씬 큰 저장 용량을 제공한다.

- 운영체제 관점에서는 디스크를 일정한 크기의 저장 공간으로 이루어진 **1차원 배열**처럼 취급
- 디스크 구조
    - 하나 이상의 자기 원판으로 구성되며 원판은 트랙으로 나뉘고, **트랙**은 **섹터**로 나뉨
    - **실린더** : 여러 원판에서 같은 위치의 트랙들을 묶은 것
    - **헤드** : 원판 표면에서 실제로 데이터를 읽고 쓰는 장치
    - **암** : 여러 개의 헤드를 묶어 함께 이동시키는 장치
- 디스크 접근 과정
    1. 암(Arm)이 목표 섹터가 속한 실린더로 이동
    2. 디스크가 회전하여 헤드가 해당 섹터 위치에 도달
    3. 실제 데이터 읽기/쓰기 작업 가능
- 디스크 접근 시간
    - **탐색 시간** : 헤드가 목표 실린더로 이동하는 데 걸리는 시간
    - **회전 지연 시간** : 디스크가 회전하여 원하는 섹터가 헤드까지 이동하는 데 걸리는 시간
    - **전송 시간** : 실제 데이터를 읽거나 쓰는 데 걸리는 시간

<br>    

### 5. 디스크 스케줄링

디스크 스케줄링은 **암의 이동 거리를 최소화**, 즉 **탐색 시간을 줄이는 데** 목표가 있다.

- **FCFS(First-Come- First-Served)**
    - 가장 먼저 온 것을 먼저 처리
    - 장점 : 공평, 기아 없음
    - 단점 : 탐색 시간이 길어짐(이동 경로가 길어짐)
- **SSTF(Shortest-Seek Time First)**
    - 현재 헤드에서 가까운 것부터 처리
    - 장점 : 탐색 시간 감소
    - 단점 : **기아 발생 가능**, 특정 요청이 언제 처리될지 예측 힘듦
- **SCAN(Elevator Algorithm)**
    - 헤드가 디스크 **한쪽 끝에서 다른 쪽 끝까지** 이동하며 경로상의 모든 요청 처리
    - 끝에 도달하면 **방향 전환**
    - 장점 : **SSTF**보다 예측 가능, 기아 없음
    - 단점 : 양 끝은 근처는 대기 시간이 길어짐
- **C-SCAN(Circular SCAN)**
    - SCAN과 유사하지만, 한쪽 방향으로만 이동
    - 끝에 도달하면 **반대쪽 끝으로 이동하여** 요청을 다시 처리
    - 장점: 더 균등한 대기 시간
    - 단점: 한 방향으로만 이동하므로 비효율적일 수 있음
- **LOOK**
    - SCAN의 개선
    - **끝까지 가지 않고 마지막 요청**에 도달하면 방향 전환
- **C-LOOK(Circular Look)**
    - C-SCAN의 개선
    - **끝까지 가지 않고 마지막 요청까지만** 이동 후 방향 전환
