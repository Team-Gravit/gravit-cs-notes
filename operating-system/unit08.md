# 동기화와 병행성(Synchronization & Concurrency)

**동기화**는 여러 프로세스나 스레드가 공유 자원에 접근할 때 데이터의 일관성을 유지하기 위한 메커니즘이다. **병행성**은 여러 작업이 동시에 실행되는 것처럼 보이게 하는 개념으로, 이 과정에서 발생하는 동기화 문제를 해결하는 것이 운영체제의 핵심 과제다.

<br>

### 1. 동기화 문제

#### **1-1. 임계 영역 (Critical Section)**

여러 프로세스가 공유하는 데이터에 접근하는 코드 영역

**임계 영역의 구조**
- **진입 영역 (Entry Section)**: 임계 영역 진입 전 허가 요청
- **임계 영역 (Critical Section)**: 공유 자원 접근 코드
- **퇴출 영역 (Exit Section)**: 임계 영역 탈출 후 다른 프로세스에게 알림
- **나머지 영역 (Remainder Section)**: 그 외 코드

<br>

#### **1-2. 임계 영역 문제 해결 조건**

| **조건** | **설명** |
| --- | --- |
| **상호 배제 (Mutual Exclusion)** | 한 프로세스가 임계 영역을 실행 중이면 다른 프로세스는 진입 불가 |
| **진행 (Progress)** | 임계 영역에 프로세스가 없으면 진입을 원하는 프로세스는 즉시 진입 가능 |
| **한정 대기 (Bounded Waiting)** | 프로세스가 임계 영역 진입을 무한정 대기하지 않음 |

<br>

### 2. 하드웨어 기반 동기화

#### **2-1. TestAndSet**

**원자적 (Atomic) 연산**으로 구현된 하드웨어 명령어

**동작 방식**
1. 현재 lock 값을 읽음
2. lock을 TRUE로 설정
3. 이전 값 반환
4. **위 3단계가 중단 없이 원자적으로 실행됨**

**상호 배제 구현**
- lock이 FALSE일 때: 이전 값 FALSE 반환 → 임계 영역 진입
- lock이 TRUE일 때: 이전 값 TRUE 반환 → 대기 (busy waiting)

**장점**
- 간단한 구현
- 다중 프로세서에서도 동작

**단점**
- **Busy Waiting** (스핀락): CPU 낭비
- 한정 대기 조건 만족 안 함 (기본 버전)

<br>

#### **2-2. Compare-And-Swap (CAS)**

현대 프로세서에서 사용하는 원자적 명령어

**동작 방식**
1. 현재 값이 예상값(expected)과 같은지 확인
2. 같으면 새 값(new_value)으로 변경
3. 현재 값 반환

**특징**
- TestAndSet보다 유연함
- Lock-Free 자료구조 구현에 활용
- Java의 AtomicInteger 등에 사용

<br>

### 3. 소프트웨어 기반 동기화

#### **3-1. 피터슨 알고리즘 (Peterson's Algorithm)**

2개의 프로세스를 위한 소프트웨어 동기화

**사용 변수**
- `flag[i]`: 프로세스 i의 진입 의사
- `turn`: 누구 차례인지

**동작 원리**
1. 자신의 flag를 TRUE로 설정 (진입 의사 표시)
2. turn을 상대방으로 설정 (양보)
3. 상대방이 진입 의사가 있고 상대방 차례면 대기
4. 그렇지 않으면 임계 영역 진입

**장점**
- 하드웨어 지원 없이 소프트웨어만으로 구현
- 3가지 조건 모두 만족

**단점**
- 2개 프로세스만 지원
- Busy Waiting (CPU 낭비)
- 현대 컴퓨터에서 명령어 재배치로 오동작 가능

<br>

### 4. 세마포어 (Semaphore)

#### **4-1. 세마포어 기본 개념**

정수 변수와 두 개의 원자적 연산으로 구성된 동기화 도구

**두 가지 연산**
- **wait() (P 연산)**: 세마포어 값 감소, 0 미만이면 대기
- **signal() (V 연산)**: 세마포어 값 증가, 대기 중인 프로세스 깨움

**장점**
- Busy Waiting 제거 (Block/Wakeup 방식)
- 간단한 사용법

<br>

#### **4-2. Binary Semaphore (Mutex)**

값이 0 또는 1인 세마포어

**동작 과정**
```
초기: mutex = 1

P1: wait(mutex) → mutex = 0, 진입
P2: wait(mutex) → mutex = -1, 대기 (blocked)
P1: signal(mutex) → mutex = 0, P2 깨움 (wakeup)
P2: 실행 재개, 임계 영역 진입
```

<br>

#### **4-3. Counting Semaphore**

여러 자원을 관리하는 세마포어

**사용 예시**
- 데이터베이스 연결 풀 (최대 10개 연결)
- 프린터 스풀러 (여러 프린터)
- 주차장 관리 (제한된 주차 공간)

<br>

### 5. 모니터 (Monitor)

세마포어보다 고수준의 동기화 도구

**특징**
- 공유 데이터와 접근 함수를 하나로 캡슐화
- 한 번에 하나의 프로세스만 모니터 내부 실행
- Condition Variable로 대기/신호 처리

**장점**
- 프로그래밍 오류 감소 (자동 상호 배제)
- 세마포어보다 사용하기 쉬움

**Java의 synchronized**
- 모니터 개념을 언어 차원에서 지원
- `synchronized` 키워드로 자동 동기화

<br>

### 6. 고전적 동기화 문제

#### **6-1. 생산자-소비자 문제 (Producer-Consumer Problem)**

한정 버퍼를 공유하는 생산자와 소비자

**문제 상황**
- 생산자: 버퍼에 데이터 추가
- 소비자: 버퍼에서 데이터 제거
- 버퍼 크기는 제한적

**사용 세마포어**
- `empty`: 빈 슬롯 개수
- `full`: 찬 슬롯 개수
- `mutex`: 버퍼 접근 상호 배제

**주의사항**
- 세마포어 순서 중요 (empty/full → mutex 순)
- 순서 바뀌면 교착 상태 발생 가능

<br>

#### **6-2. 독자-저자 문제 (Readers-Writers Problem)**

데이터를 읽는 독자와 쓰는 저자 간의 동기화

**규칙**
- 여러 독자는 동시에 읽기 가능
- 저자는 배타적 접근 필요 (다른 독자/저자 없어야 함)

**사용 변수**
- `readcount`: 현재 읽는 독자 수
- `mutex`: readcount 보호
- `wrt`: 저자 상호 배제

**두 가지 변형**
1. **독자 우선**: 독자가 계속 오면 저자 기아 발생
2. **저자 우선**: 저자 대기 중이면 새 독자 차단

<br>

#### **6-3. 식사하는 철학자 문제 (Dining Philosophers Problem)**

5명의 철학자가 원탁에서 식사

**문제 상황**
- 5개의 젓가락, 각 철학자는 양쪽 젓가락 2개 필요
- 모든 철학자가 왼쪽 젓가락을 동시에 집으면 교착 상태

**교착 상태 발생**
```
모든 철학자가 왼쪽 젓가락을 동시에 집음
→ 오른쪽 젓가락을 영원히 기다림
→ 교착 상태!
```

**해결 방법**

**1) 비대칭 접근**
- 짝수 철학자: 왼쪽 → 오른쪽
- 홀수 철학자: 오른쪽 → 왼쪽

**2) 최대 4명만 동시 식사**
- 5명 중 최대 4명만 식탁에 앉도록 제한
- 세마포어로 구현

**3) 두 젓가락을 동시에 집기**
- 양쪽 젓가락을 모두 사용 가능할 때만 집음

<br>

### 7. 동기화 문제들

#### **7-1. 교착 상태 (Deadlock)**

프로세스들이 서로 자원을 기다리며 무한정 대기

**교착 상태 발생 조건 (4가지 모두 만족)**

1. **상호 배제**: 한 번에 하나의 프로세스만 자원 사용
2. **점유와 대기**: 자원을 가진 채 다른 자원 대기
3. **비선점**: 강제로 자원을 빼앗을 수 없음
4. **순환 대기**: 자원 대기가 순환 구조

**해결 방법**
- 자원 할당 순서 정하기
- 타임아웃 설정
- 은행원 알고리즘 (안전 상태 확인)
- 교착 상태 탐지 및 회복

<br>

#### **7-2. 기아 상태 (Starvation)**

프로세스가 자원을 무한정 할당받지 못함

**발생 원인**
- 우선순위가 낮은 프로세스
- 불공정한 스케줄링 알고리즘
- 자원 할당 정책 문제

**해결: 에이징 (Aging)**
- 대기 시간에 비례하여 우선순위 증가
- 일정 시간 대기 후 우선순위 상승

<br>

#### **7-3. 우선순위 역전 (Priority Inversion)**

낮은 우선순위 프로세스가 높은 우선순위 프로세스를 지연

**발생 시나리오**
1. 낮은 우선순위 L이 자원 잠금
2. 높은 우선순위 H가 도착, 자원 대기
3. 중간 우선순위 M이 도착, L을 선점
4. H는 M이 끝날 때까지 대기 (역전!)

**해결: 우선순위 상속 (Priority Inheritance)**
1. H가 L이 점유한 자원 대기
2. L의 우선순위를 임시로 H와 같게 상승
3. L이 자원 해제
4. L의 우선순위 원래대로 복원

**실제 사례**
- Mars Pathfinder (1997년 NASA 화성 탐사선)
- 우선순위 역전으로 시스템 재부팅 반복
- 우선순위 상속으로 해결

<br>

### 8. 동기화 기법 비교

| **기법** | **장점** | **단점** | **사용 예시** |
| --- | --- | --- | --- |
| **TestAndSet** | 간단한 구현 | Busy Waiting | 짧은 임계 영역 |
| **세마포어** | Busy Waiting 제거 | 프로그래밍 오류 가능 | 자원 개수 제한 |
| **모니터** | 사용 편리, 오류 적음 | 언어 지원 필요 | 고수준 동기화 |
| **Mutex** | 단순한 상호 배제 | 자원 개수 제한 안 됨 | 임계 영역 보호 |

<br>
