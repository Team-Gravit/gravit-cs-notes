# 프로세스 관리(Process Management)

**프로세스 관리**는 운영체제가 여러 프로세스의 생성, 실행, 종료를 효율적으로 제어하고 CPU를 공평하게 할당하는 일련의 활동이다. 프로세스 관리의 핵심은 한정된 CPU 자원을 여러 프로세스에게 최적으로 분배하여 시스템 성능과 사용자 경험을 극대화하는 것이다.

<br>

### 1. 프로세스 관리의 주요 책임

운영체제는 프로세스 관리를 위해 다음 활동을 수행한다.

| **책임** | **설명** |
| --- | --- |
| **프로세스 생성 및 종료** | 사용자/시스템 프로세스의 생성과 삭제 |
| **프로세스 스케줄링** | CPU와 스레드를 프로세스에 할당 |
| **프로세스 중단 및 재개** | 프로세스 실행의 일시 정지 및 재개 |
| **프로세스 동기화** | 프로세스 간 협력을 위한 동기화 메커니즘 제공 |
| **프로세스 통신** | IPC(Inter-Process Communication) 메커니즘 제공 |

<br>

### 2. 프로세스 생성 (Process Creation)

### **2-1. 프로세스 계층 구조**

운영체제에서 프로세스는 **트리 구조**로 조직된다. 프로세스는 다른 프로세스를 생성할 수 있으며, 생성한 프로세스를 **부모 프로세스**, 생성된 프로세스를 **자식 프로세스**라고 한다.

### **2-2. fork() 시스템 콜**

- *fork()**는 현재 프로세스를 복제하여 새로운 자식 프로세스를 생성한다.

**fork() 반환 값**

- **부모 프로세스**: 자식 프로세스의 PID (양수)
- **자식 프로세스**: 0
- **실패**: -1

**fork() 이후 메모리 상태**

- 부모와 자식은 각각 독립된 메모리 공간을 가짐
- 변수 값을 변경해도 서로 영향을 주지 않음

> 💡 Copy-on-Write (COW): 실제로는 fork() 직후에는 메모리를 완전히 복사하지 않고, 부모와 자식이 같은 물리 메모리를 공유한다. 어느 한쪽이 메모리를 수정할 때만 실제 복사가 발생한다 (성능 최적화).
> 

<br>

### **2-3. exec() 계열 함수**

- *exec()**는 현재 프로세스의 메모리를 새로운 프로그램으로 교체한다.

**exec() 계열 함수 비교**

| **함수** | **인자 전달** | **경로 검색** | **환경 변수** |
| --- | --- | --- | --- |
| **execl()** | 리스트 | X | X |
| **execlp()** | 리스트 | O (PATH 검색) | X |
| **execle()** | 리스트 | X | O (전달 가능) |
| **execv()** | 배열 | X | X |
| **execvp()** | 배열 | O (PATH 검색) | X |
| **execve()** | 배열 | X | O (전달 가능) |

> 💡 exec() 성공 시 원래 프로그램으로 돌아오지 않는다. PID는 유지되지만 프로그램 전체가 교체된다.
> 

<br>

### **2-4. fork() + exec() 조합**

새로운 프로그램을 실행하려면 fork()와 exec()를 함께 사용한다. 이것이 쉘(Shell)이 명령어를 실행하는 방식이다.

**동작 과정**

1. 쉘이 fork()로 자식 프로세스 생성
2. 자식이 exec()로 명령어 실행
3. 부모(쉘)는 wait()로 자식 종료 대기

<br>

### 3. 프로세스 종료 (Process Termination)

### **3-1. 정상 종료**

프로세스는 다음과 같은 방법으로 정상 종료된다.

**exit() vs _exit()**

| **구분** | **exit()** | **_exit()** |
| --- | --- | --- |
| **버퍼 처리** | 표준 I/O 버퍼 flush | 버퍼 flush 안 함 |
| **cleanup** | atexit() 핸들러 실행 | 핸들러 실행 안 함 |
| **사용 시기** | 일반적인 종료 | 긴급 종료, fork() 후 자식 |

<br>

### **3-2. 비정상 종료**

- **abort()**: 프로세스 강제 종료
- **시그널**: kill, SIGTERM, SIGKILL 등
- **예외**: Segmentation fault, Division by zero

<br>

### **3-3. 좀비 프로세스 (Zombie Process)**

자식 프로세스가 종료되었지만 부모가 wait()를 호출하지 않아 PCB가 남아있는 상태

**특징**

- 메모리와 리소스는 반환되었지만 프로세스 테이블 항목은 남아있음
- `ps` 명령어에서 상태가 'Z'로 표시됨
- 시스템 리소스 낭비 (프로세스 테이블 슬롯 차지)

**좀비 프로세스 해결 방법**

- **wait()** 또는 **waitpid()** 호출하여 자식 프로세스 정리
- **SIGCHLD 시그널 핸들러** 등록: `signal(SIGCHLD, SIG_IGN)`

<br>

### **3-4. 고아 프로세스 (Orphan Process)**

부모 프로세스가 자식보다 먼저 종료된 경우, 자식은 **고아 프로세스**가 된다. 운영체제는 고아 프로세스를 **init 프로세스**(PID 1)가 입양하도록 한다.

**특징**

- init 프로세스가 새로운 부모가 되어 자동으로 wait() 처리
- 시스템에 해를 끼치지 않음 (좀비와 달리)

<br>

### 4. 프로세스 간 통신 (IPC: Inter-Process Communication)

프로세스는 기본적으로 독립된 메모리 공간을 가지므로 데이터를 공유하려면 **IPC**를 사용해야 한다.

<br>

### **4-1. 파이프 (Pipe)**

**파이프**는 단방향 통신 채널로, 부모-자식 프로세스 간 통신에 사용된다.

**특징**

- `pipe()` 시스템 콜로 생성
- `fd[0]`: 읽기용, `fd[1]`: 쓰기용
- 단방향 통신 (한쪽은 쓰기, 한쪽은 읽기)
- 버퍼 크기 제한 있음

<br>

### **4-2. 명명된 파이프 (Named Pipe / FIFO)**

관련 없는 프로세스 간 통신이 가능한 파이프

**특징**

- 파일 시스템에 이름을 가진 파일로 존재
- `mkfifo()` 또는 `mkfifo` 명령어로 생성
- 관련 없는 프로세스 간 통신 가능
- 단방향 통신

<br>

### **4-3. 메시지 큐 (Message Queue)**

프로세스 간 메시지를 전송하는 큐 자료구조

**특징**

- 구조화된 메시지 전달
- 메시지 타입별 선택적 수신 가능
- 비동기 통신 지원
- 커널이 메시지 버퍼 관리

<br>

### **4-4. 공유 메모리 (Shared Memory)**

가장 빠른 IPC 방법. 여러 프로세스가 같은 메모리 영역을 공유한다.

**특징**

- 가장 빠른 IPC 방법 (커널 개입 최소)
- 동기화 문제 주의 필요 (세마포어와 함께 사용)
- 대용량 데이터 전송에 적합

<br>

### **4-5. 시그널 (Signal)**

프로세스에게 이벤트를 알리는 비동기 메커니즘

**주요 시그널**

| **시그널** | **번호** | **의미** | **기본 동작** |
| --- | --- | --- | --- |
| **SIGHUP** | 1 | 터미널 연결 종료 | 종료 |
| **SIGINT** | 2 | 인터럽트 (Ctrl+C) | 종료 |
| **SIGQUIT** | 3 | Quit (Ctrl+\\) | 종료 + 코어 덤프 |
| **SIGKILL** | 9 | 강제 종료 | 종료 (무시 불가) |
| **SIGSEGV** | 11 | Segmentation fault | 종료 + 코어 덤프 |
| **SIGTERM** | 15 | 정상 종료 요청 | 종료 |
| **SIGCHLD** | 17 | 자식 프로세스 상태 변화 | 무시 |
| **SIGSTOP** | 19 | 프로세스 중지 | 중지 (무시 불가) |
| **SIGCONT** | 18 | 중지된 프로세스 재개 | 재개 |

<br>

### **IPC 방법 비교**

| **방법** | **속도** | **복잡도** | **양방향** | **적합한 경우** |
| --- | --- | --- | --- | --- |
| **파이프** | 보통 | 낮음 | 단방향 | 부모-자식 간 간단한 통신 |
| **Named Pipe** | 보통 | 낮음 | 단방향 | 관련 없는 프로세스 간 통신 |
| **메시지 큐** | 보통 | 중간 | 양방향 | 구조화된 메시지 전달 |
| **공유 메모리** | 빠름 | 높음 | 양방향 | 대용량 데이터 공유 |
| **시그널** | 빠름 | 낮음 | 단방향 | 이벤트 알림, 간단한 제어 |
| **소켓** | 느림 | 높음 | 양방향 | 네트워크 통신, 분산 시스템 |

<br>

### 5. CPU 스케줄링 알고리즘

### **5-1. FCFS (First-Come, First-Served)**

가장 먼저 도착한 프로세스를 먼저 처리하는 비선점 알고리즘

**장점**

- 구현이 간단
- 공평함 (먼저 온 순서대로)

**단점**

- **Convoy Effect**: 긴 프로세스 뒤에 짧은 프로세스들이 대기하여 평균 대기 시간 증가

<br>

### **5-2. SJF (Shortest Job First)**

실행 시간이 가장 짧은 프로세스를 먼저 실행

**비선점 SJF**

- 프로세스가 실행되면 완료될 때까지 계속 실행

**선점 SJF (SRTF: Shortest Remaining Time First)**

- 더 짧은 프로세스가 도착하면 현재 실행 중인 프로세스 중단하고 교체

**장점**

- 평균 대기 시간 최소화 (이론적으로 최적)

**단점**

- **기아 현상 (Starvation)**: 긴 프로세스가 무한정 대기
- 실행 시간을 미리 알기 어려움 (예측 필요)

<br>

### **5-3. Round Robin (RR)**

각 프로세스에 동일한 시간 할당량(Time Quantum)을 부여하는 선점 알고리즘

**Time Quantum 선택**

- **너무 크면**: FCFS와 동일해짐
- **너무 작으면**: 문맥 교환 오버헤드 증가
- **적정 값**: 10-100ms (일반적으로)

**장점**

- 공평한 CPU 시간 분배
- 응답 시간이 빠름
- 대화형 시스템에 적합

**단점**

- 평균 대기 시간이 SJF보다 길 수 있음
- 문맥 교환 오버헤드

<br>

### **5-4. Priority Scheduling**

우선순위가 높은 프로세스를 먼저 실행

**우선순위 결정 요소**

- 프로세스 유형 (시스템 > 사용자)
- CPU 사용 시간
- 메모리 요구량
- I/O 대 CPU burst 비율

**에이징 (Aging)**

기아 현상 방지를 위해 대기 시간에 비례하여 우선순위를 점진적으로 높이는 기법

**장점**

- 중요한 작업 우선 처리
- 유연한 스케줄링

**단점**

- 기아 현상 발생 가능 (에이징으로 해결)
- 우선순위 역전 문제

<br>

### **5-5. Multilevel Queue Scheduling**

프로세스를 여러 큐로 분류하여 각 큐마다 다른 알고리즘 적용

**큐 분류 예시**

- **System Processes**: 최고 우선순위, FCFS
- **Interactive Processes**: RR (q=8ms)
- **Batch Processes**: RR (q=16ms) 또는 FCFS

**특징**

- 프로세스는 한 큐에 고정
- 각 큐는 독립적인 스케줄링 정책 사용

<br>

### **5-6. Multilevel Feedback Queue**

프로세스가 큐 간 이동 가능한 동적 스케줄링

**동작 방식**

- 새 프로세스는 최상위 큐에 진입
- Time quantum을 다 쓰면 하위 큐로 이동 (강등)
- I/O 작업 후 상위 큐로 이동 가능 (승격)

**장점**

- CPU burst가 짧은 프로세스 우대 (응답 시간 개선)
- I/O bound 프로세스 우대
- 적응적 스케줄링

<br>

### 6. 스케줄링 성능 평가 지표

| **지표** | **설명** | **계산 방법** |
| --- | --- | --- |
| **CPU 이용률** | CPU가 작업을 수행한 시간 비율 | (busy time / total time) × 100% |
| **처리량** | 단위 시간당 완료된 프로세스 수 | 완료 프로세스 수 / 총 시간 |
| **반환 시간** | 프로세스 제출부터 완료까지 시간 | 완료 시간 - 도착 시간 |
| **대기 시간** | Ready Queue에서 대기한 총 시간 | 반환 시간 - 실행 시간 |
| **응답 시간** | 첫 응답까지 걸린 시간 | 첫 실행 시간 - 도착 시간 |

**목표**

- **최대화**: CPU 이용률, 처리량
- **최소화**: 반환 시간, 대기 시간, 응답 시간

<br>

### 7. 스케줄링 알고리즘 비교

| **알고리즘** | **선점** | **평균 대기시간** | **응답시간** | **기아 현상** | **적합한 시스템** |
| --- | --- | --- | --- | --- | --- |
| **FCFS** | 비선점 | 나쁨 | 나쁨 | 없음 | 배치 시스템 |
| **SJF** | 비선점 | 최적 | 나쁨 | 있음 | 배치 시스템 |
| **SRTF** | 선점 | 최적 | 좋음 | 있음 | 대화형 시스템 |
| **RR** | 선점 | 보통 | 좋음 | 없음 | 시분할 시스템 |
| **Priority** | 양쪽 | 보통 | 보통 | 있음 (에이징 필요) | 실시간 시스템 |
| **MLFQ** | 선점 | 좋음 | 좋음 | 없음 | 범용 시스템 |
