# 시스템 콜(System Call)

**시스템 콜**은 응용 프로그램이 운영체제의 커널에게 서비스를 요청하는 **인터페이스**다. 사용자 모드에서 실행되는 프로그램이 하드웨어 자원에 접근하거나 특권 명령을 실행하기 위해서는 반드시 시스템 콜을 통해 커널 모드로 전환해야 한다.

<br>

### 1. 시스템 콜의 필요성

응용 프로그램은 사용자 모드에서 실행되며, 직접 하드웨어에 접근할 수 없다. 시스템의 안정성과 보안을 위해 하드웨어 제어는 커널만 수행할 수 있다.

**직접 접근 불가능한 작업들**
- 파일 입출력 (open, read, write, close)
- 네트워크 통신 (socket, send, recv)
- 프로세스 생성 및 관리 (fork, exec, wait)
- 메모리 할당 (malloc 내부적으로 brk, mmap 사용)
- 장치 제어 (ioctl)

<br>

### 2. 이중 모드 (Dual Mode)

운영체제는 사용자 모드와 커널 모드를 구분하여 시스템을 보호한다.

| **구분** | **사용자 모드** | **커널 모드** |
| --- | --- | --- |
| **권한** | 제한된 명령어만 실행 가능 | 모든 명령어 실행 가능 |
| **접근** | 하드웨어 직접 접근 불가 | 하드웨어 직접 접근 가능 |
| **실행** | 응용 프로그램 | 운영체제 커널 |
| **모드 비트** | 1 | 0 |
| **예시** | 워드프로세서, 웹 브라우저 | 파일 시스템, 메모리 관리 |

<br>

### 3. 시스템 콜 동작 과정
```
1. 응용 프로그램이 시스템 콜 함수 호출 (예: read())
2. 라이브러리 함수가 시스템 콜 번호를 레지스터에 설정
3. 소프트웨어 인터럽트(trap) 발생
4. CPU가 커널 모드로 전환 (모드 비트 0으로 변경)
5. 커널이 시스템 콜 번호를 확인
6. 시스템 콜 테이블에서 해당 서비스 루틴 호출
7. 커널이 요청된 작업 수행
8. 사용자 모드로 복귀 (모드 비트 1로 변경)
9. 응용 프로그램으로 결과 반환
```

<br>

### 4. 매개변수 전달 방법

시스템 콜 실행에 필요한 매개변수를 전달하는 방법은 세 가지가 있다.

**1) 레지스터 전달**
- 매개변수를 CPU 레지스터에 저장
- 가장 빠른 방법
- 매개변수 개수가 레지스터 수보다 많으면 사용 불가

**2) 메모리 블록 전달**
- 메모리에 매개변수 저장
- 메모리 주소를 레지스터에 저장
- 매개변수 개수 제한 없음

**3) 스택 전달**
- 프로그램이 매개변수를 스택에 push
- 운영체제가 스택에서 매개변수 pop
- 매개변수 개수 제한 없음

<br>

### 5. 시스템 콜의 유형

시스템 콜은 기능에 따라 다섯 가지로 분류된다.

#### **5-1. 프로세스 제어 (Process Control)**

| **시스템 콜** | **기능** |
| --- | --- |
| **fork()** | 새로운 프로세스 생성 (자식 프로세스) |
| **exec()** | 프로세스를 새로운 프로그램으로 교체 |
| **wait()** | 자식 프로세스 종료 대기 |
| **exit()** | 프로세스 종료 |
| **getpid()** | 현재 프로세스 ID 반환 |

<br>

#### **5-2. 파일 관리 (File Management)**

| **시스템 콜** | **기능** |
| --- | --- |
| **open()** | 파일 열기 |
| **read()** | 파일 읽기 |
| **write()** | 파일 쓰기 |
| **close()** | 파일 닫기 |
| **lseek()** | 파일 포인터 이동 |

<br>

#### **5-3. 장치 관리 (Device Management)**

| **시스템 콜** | **기능** |
| --- | --- |
| **ioctl()** | 장치 제어 |
| **read()** | 장치에서 읽기 |
| **write()** | 장치에 쓰기 |

<br>

#### **5-4. 정보 유지 (Information Maintenance)**

| **시스템 콜** | **기능** |
| --- | --- |
| **time()** | 현재 시간 가져오기 |
| **alarm()** | 알람 설정 |
| **sleep()** | 프로세스 일시 정지 |

<br>

#### **5-5. 통신 (Communication)**

| **시스템 콜** | **기능** |
| --- | --- |
| **pipe()** | 파이프 생성 (프로세스 간 통신) |
| **socket()** | 소켓 생성 (네트워크 통신) |
| **shmget()** | 공유 메모리 생성 |
| **mmap()** | 메모리 매핑 |

<br>

### 6. 주요 시스템 콜

#### **6-1. fork() - 프로세스 생성**

**fork()**는 현재 프로세스를 복제하여 새로운 자식 프로세스를 생성한다.

**fork() 반환 값**
- **부모 프로세스**: 자식 프로세스의 PID (양수)
- **자식 프로세스**: 0
- **실패**: -1

<br>

#### **6-2. exec() - 프로세스 교체**

**exec()** 계열 함수는 현재 프로세스의 메모리 공간을 새로운 프로그램으로 교체한다.

**exec() 계열 함수**

| **함수** | **특징** |
| --- | --- |
| **execl()** | 인자를 리스트로 전달 |
| **execv()** | 인자를 배열로 전달 |
| **execlp()** | 경로 검색 + 인자 리스트 |
| **execvp()** | 경로 검색 + 인자 배열 |

> 💡 exec() 성공 시 원래 프로그램으로 돌아오지 않는다. PID는 유지되지만 프로그램 전체가 교체된다.

<br>

#### **6-3. wait() - 자식 프로세스 대기**

**wait()**는 자식 프로세스가 종료될 때까지 부모 프로세스를 대기시킨다.

**wait() vs waitpid()**

| **함수** | **기능** |
| --- | --- |
| **wait(&status)** | 임의의 자식 프로세스 종료 대기 |
| **waitpid(pid, &status, options)** | 특정 자식 프로세스 종료 대기 |

<br>

### 7. 시스템 콜 vs 함수 호출

| **구분** | **시스템 콜** | **함수 호출** |
| --- | --- | --- |
| **호출 대상** | 운영체제 커널 | 동일 프로그램 내 함수 |
| **모드 전환** | 사용자 모드 → 커널 모드 | 모드 전환 없음 |
| **오버헤드** | 높음 (모드 전환 비용) | 낮음 (스택 조작만) |
| **권한** | 특권 명령 실행 가능 | 제한된 권한 |
| **예시** | read(), write(), fork() | printf(), strlen() |

<br>

### 8. 라이브러리 함수 vs 시스템 콜

| **구분** | **라이브러리 함수** | **시스템 콜** |
| --- | --- | --- |
| **추상화** | 높음 (사용하기 쉬움) | 낮음 (직접 제어) |
| **이식성** | 높음 (표준 C 라이브러리) | 낮음 (OS 의존적) |
| **성능** | 버퍼링으로 효율적 | 직접 제어 가능 |
| **예시** | printf(), malloc() | write(), brk() |

<br>

### 9. 인터럽트와 시스템 콜

**인터럽트(Interrupt)**는 하드웨어나 소프트웨어가 CPU에게 즉각적인 처리를 요청하는 메커니즘이다.

| **구분** | **인터럽트** | **시스템 콜** |
| --- | --- | --- |
| **발생 주체** | 하드웨어 또는 예외 상황 | 프로그램의 명시적 요청 |
| **발생 시점** | 비동기적 (언제든지) | 동기적 (명령 실행 시) |
| **목적** | 긴급한 이벤트 처리 | 운영체제 서비스 요청 |
| **예시** | 키보드 입력, 타이머 | fork(), read(), write() |

> 💡 시스템 콜은 **소프트웨어 인터럽트(Trap)**를 통해 구현된다.
