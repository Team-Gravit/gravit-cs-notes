# 프로세스 기초(Process Basics)

**프로세스**는 **실행 중인 프로그램**으로, 디스크에 저장된 프로그램이 메모리에 적재되어 CPU에 의해 실행되는 상태를 의미한다. 프로세스는 운영체제가 관리하는 가장 기본적인 실행 단위이며, 각 프로세스는 독립된 메모리 공간과 시스템 자원을 할당받는다.

<br>

### 1. 프로세스의 정의

- **프로그램(Program)**은 디스크에 저장된 실행 가능한 파일로, 수동적(Passive)인 존재이다. 반면 **프로세스(Process)**는 메모리에 적재되어 실행 중인 프로그램으로, 능동적(Active)인 존재이다.

<img src="https://github.com/user-attachments/assets/c48bd1ee-2643-4598-89cd-78d17cd8ed4f" alt="Frame 1171275940" width="100%" />


> 💡 하나의 프로그램에서 여러 프로세스가 생성될 수 있다. 예를 들어 Chrome 브라우저를 두 개 실행하면 두 개의 독립적인 프로세스가 생성된다.
> 

<br>

### 2. 프로세스의 메모리 구조

프로세스는 메모리 상에서 네 가지 영역으로 구성된다.

<img src="https://github.com/user-attachments/assets/c2ddcd0b-56d0-4c01-9950-4cebf8ad73b5" alt="Frame 1171275941" width="100%" />


<br>

| **영역** | **내용** | **특징** |
| --- | --- | --- |
| **코드(Code)** | 실행할 프로그램의 기계어 코드 | 읽기 전용, 프로그램 실행 중 변경되지 않음 |
| **데이터(Data)** | 전역 변수, 정적 변수 | 프로그램 시작 시 할당, 종료 시 해제 |
| **힙(Heap)** | 동적 할당 메모리 | 프로그래머가 수동으로 할당/해제 |
| **스택(Stack)** | 함수 호출 정보, 지역 변수 | 함수 호출 시 자동 할당, 반환 시 해제 |

<br>

### 3. 프로세스 문맥(Process Context)

**프로세스 문맥**은 프로세스의 특정 시점의 상태를 표현하는 모든 정보를 의미한다. 운영체제는 프로세스 문맥을 저장하여 프로세스를 중단하고 재개할 수 있다.

<br>

### **프로세스 문맥의 구성 요소**

**1) 하드웨어 문맥(Hardware Context)**

- **프로그램 카운터(PC)**: 다음에 실행할 명령어의 주소
- **레지스터**: CPU 레지스터들의 현재 값
- 프로세스가 CPU에서 어디까지 실행되었는지 파악

**2) 메모리 문맥(Memory Context)**

- **주소 공간**: Code, Data, Stack, Heap 영역의 내용
- 프로세스가 어떤 데이터를 가지고 있는지 파악

**3) 커널 문맥(Kernel Context)**

- **PCB(Process Control Block)**: 프로세스 제어 정보
- **커널 스택**: 시스템 콜 실행 시 사용하는 스택
- 운영체제가 프로세스를 어떻게 관리하고 있는지 파악

<br>

### 4. 프로세스 상태(Process State)

프로세스는 실행되면서 여러 상태를 전이한다.

<br>

### **기본 5가지 상태**

<img src="https://github.com/user-attachments/assets/48a4d3c4-ac59-46c2-993e-74fee61ed2b9" alt="Frame 1171275943" width="100%" />


<br>

| **상태** | **설명** |
| --- | --- |
| **New (생성)** | 프로세스가 생성된 상태 |
| **Ready (준비)** | CPU를 할당받을 준비가 완료된 상태. 다른 조건은 모두 만족하고 CPU만 기다림 |
| **Running (실행)** | CPU를 할당받아 명령어를 실행 중인 상태 |
| **Waiting (대기)** | I/O 작업 등 이벤트 발생을 기다리는 상태. CPU를 할당받아도 실행 불가 |
| **Terminated (종료)** | 프로세스 실행이 완료된 상태. 아직 완전히 제거되지는 않음 |

<br>

### **상태 전이 과정**

- **New → Ready**: 프로세스 생성 완료
- **Ready → Running**: 스케줄러가 프로세스 선택 (Dispatch)
- **Running → Ready**: 할당된 CPU 시간 만료 (Time-out, Preemption)
- **Running → Waiting**: I/O 요청이나 이벤트 대기
- **Waiting → Ready**: I/O 완료 또는 이벤트 발생
- **Running → Terminated**: 프로세스 실행 완료

<br>

### **확장된 상태: Suspended (중단)**

메모리가 부족할 때 운영체제는 프로세스를 디스크로 **스왑 아웃(Swap out)**하여 메모리 공간을 확보한다.

<img src="https://github.com/user-attachments/assets/40243641-2340-4163-a893-a5983fd205a2" alt="Frame (4)" width="100%" />


- **Suspended Ready**: 메모리에서 디스크로 스왑된 Ready 상태
- **Suspended Waiting**: 메모리에서 디스크로 스왑된 Waiting 상태

> 💡 Waiting vs Suspended: Waiting은 자신이 요청한 이벤트가 완료되면 Ready로 전이되지만, Suspended는 외부(운영체제)에서 다시 메모리에 적재해야 실행 가능하다.
> 

<br>

### 5. 프로세스 제어 블록(Process Control Block, PCB)

**PCB**는 운영체제가 각 프로세스를 관리하기 위해 유지하는 자료구조로, 프로세스에 대한 모든 정보를 담고 있다. PCB는 커널의 주소 공간에 저장된다.

<br>

### **PCB의 구성 요소**

<img src="https://github.com/user-attachments/assets/23f2e592-4b11-4c75-a251-fb61d177d9d6" alt="Frame 1171275945 (1)" width="100%" />


<br>

| **정보** | **내용** |
| --- | --- |
| **프로세스 식별 정보** | Process ID (PID), 부모 프로세스 ID (PPID) |
| **프로세스 상태** | New, Ready, Running, Waiting, Terminated |
| **프로그램 카운터** | 다음에 실행할 명령어의 주소 |
| **CPU 레지스터** | 누산기, 인덱스 레지스터, 스택 포인터, 범용 레지스터 등 |
| **스케줄링 정보** | 우선순위, 스케줄링 큐 포인터, 스케줄링 파라미터 |
| **메모리 관리 정보** | Base/Limit 레지스터, 페이지 테이블, 세그먼트 테이블 |
| **계정 정보** | CPU 사용 시간, 실제 사용 시간, 시간 제한 |
| **입출력 상태 정보** | 할당된 I/O 장치 목록, 열린 파일 목록 |

<br>

### 6. 문맥 교환(Context Switch)

**문맥 교환**은 CPU가 현재 실행 중인 프로세스를 중단하고 다른 프로세스를 실행하기 위해 프로세스 문맥을 저장하고 복원하는 과정이다.

<br>

### **문맥 교환 과정**

<img src="https://github.com/user-attachments/assets/be151e69-ef99-4b79-8c3e-98edd456d716" alt="Frame 1171275946 (2)" width="100%" />


<br>

### **문맥 교환이 발생하는 경우**

1. **인터럽트(Interrupt)**
    - 하드웨어 인터럽트: I/O 완료, 타이머 만료 등
    - 소프트웨어 인터럽트(트랩): 예외 상황, 시스템 콜
2. **시분할(Time Sharing)**
    - CPU 할당 시간(Time Quantum) 만료
    - 더 높은 우선순위의 프로세스 등장

<br>

> 💡 시스템 콜이나 인터럽트가 발생해도 같은 프로세스로 복귀한다면 문맥 교환이 아니다. 문맥 교환은 CPU가 다른 프로세스로 전환될 때만 발생한다.
> 

<br>

### **문맥 교환 오버헤드(Overhead)**

문맥 교환은 CPU가 실제 작업을 수행하지 않는 순수한 오버헤드다.

**오버헤드 요인**

- PCB 저장 및 복원 시간
- 캐시 메모리 무효화 (Cache Flush)
- TLB(Translation Lookaside Buffer) 초기화

<br>

### 7. 프로세스 스케줄링 큐

운영체제는 여러 큐를 사용하여 프로세스를 관리한다.

<br>

### **주요 스케줄링 큐**

<img src="https://github.com/user-attachments/assets/5e71a53a-6885-4432-a30f-d9c2304a7505" alt="Frame 1171275947" width="100%" />


**1) Job Queue (작업 큐)**

- 시스템에 존재하는 모든 프로세스
- 디스크에서 메모리 할당을 기다리는 프로세스

**2) Ready Queue (준비 큐)**

- 메모리에 적재되어 CPU 할당을 기다리는 프로세스
- 실행 준비가 완료된 프로세스들의 집합

**3) Device Queue (장치 큐)**

- 특정 I/O 장치를 사용하기 위해 대기하는 프로세스
- 각 I/O 장치마다 별도의 큐 존재



<br>

### 8. 스케줄러의 종류

스케줄러는 프로세스에게 자원을 할당하는 순서와 방법을 결정한다.

<br>

| **스케줄러** | **역할** | **빈도** |
| --- | --- | --- |
| **장기 스케줄러** (Job Scheduler) | 디스크의 프로세스를 메모리로 적재 결정. **Degree of Multiprogramming** 제어 | 낮음 (분, 시간 단위) |
| **단기 스케줄러** (CPU Scheduler) | Ready Queue에서 실행할 프로세스 선택. CPU 할당 | 높음 (밀리초 단위) |
| **중기 스케줄러** (Swapper) | 메모리 부족 시 프로세스를 디스크로 스왑 아웃. Degree of Multiprogramming 제어 | 중간 (초 단위) |

<br>

### **Degree of Multiprogramming**

메모리에 동시에 존재하는 프로세스의 수를 의미한다.

- 장기 스케줄러가 메모리 적재를 결정하여 증가
- 중기 스케줄러가 스왑 아웃하여 감소

<br>

### 9. 프로세스 식별자(Process Identifier, PID)

운영체제는 각 프로세스를 고유한 **PID**로 식별한다.

```
# Linux/Unix에서 프로세스 확인
$ ps aux

# 특정 프로세스 정보 확인
$ ps -p 1234

# 프로세스 트리 구조 확인
$ pstree
```

- **PID = 0**: Swapper (커널 스케줄러)
- **PID = 1**: init 또는 systemd (모든 프로세스의 조상)
- **PPID**: 부모 프로세스의 PID

<br>

### 10. 프로세스 vs 프로그램

| **구분** | **프로그램** | **프로세스** |
| --- | --- | --- |
| **정의** | 디스크에 저장된 실행 파일 | 메모리에서 실행 중인 프로그램 |
| **상태** | 정적(Static), 수동적(Passive) | 동적(Dynamic), 능동적(Active) |
| **구성** | 코드와 데이터 | Code, Data, Stack, Heap |
| **자원** | 자원 미할당 | CPU, 메모리 등 자원 할당 |
| **프로그램 카운터** | 없음 | 존재 (다음 실행 명령 추적) |
| **개수** | 하나의 실행 파일 | 동일 프로그램에서 여러 프로세스 가능 |

<br>

### 11. 멀티프로그래밍과 시분할

**멀티프로그래밍(Multiprogramming)**

- 여러 프로세스를 메모리에 동시에 적재
- CPU 유휴 시간을 최소화하여 CPU 이용률 극대화
- 한 프로세스가 I/O 대기 중일 때 다른 프로세스 실행

**시분할(Time Sharing)**

- CPU 시간을 작은 단위로 분할하여 각 프로세스에 순환 할당
- 사용자에게 빠른 응답 시간 제공
- 여러 사용자가 동시에 시스템 사용하는 것처럼 느낌

<br>
