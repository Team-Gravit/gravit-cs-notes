## CPU 스케줄링

CPU 스케줄링은 운영체제가 **여러 프로세스 중 어떤 프로세스에 CPU를 할당할지 결정**하는 메커니즘이다.

한정된 자원을 **효율적이고 공평하게 분배**하는 것을 목적으로 한다.

<br>

### 1. 선점형 스케줄링

- 실행 중인 프로세스를 **강제로 종료**하고 다른 프로세스에 CPU 할당
- CPU 반납 시점 : 인터럽트 발생 등
- 장점 : 우선 순위가 높은 프로세스 즉시 실행 가능, 실시간 시스템에 적합
- 단점 : 컨텍스트 스위칭이 자주 발생하여 **오버헤드 발생**
- ex) Round Robin, SRTF, Priority(선점형)

<br>

### 2. 비선점형 스케줄링

- 실행 중인 프로세스가 **자발적으로 CPU를 반납**할 때까지 대기
- CPU 반납 시점 : 프로세스 종료, yield() 호출 등
- 장점 : 컨텍스트 스위칭 **오버헤드가 작음**
- 단점 : 한 프로세스가 **CPU를 독점**할 수 있음
- ex) FCFS, SJF, Priority(비선점형)

<br>

### 3. 주요 스케줄링 알고리즘

**FCFS(First-Come, First-Served)**

**선입 선출**로 먼저 들어온 프로세스가 먼저 실행된다.

- **비선점형 스케줄링 알고리즘**이기 때문에 컨텍스트 스위칭 오버헤드가 작다.
- 실행 시간이 긴 프로세스가 먼저 실행되면 대기 시간이 길어진다. **Convoy Effect 발생**

💡  Convoy Effect(호위효과)  **:** 앞선 프로세스가 실행 시간이 길다면 실행 시간이 짧은 프로세스가 실행되지 못하고 뒤에서 대기하는 것을 가리키는 효과이다. 

<img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/operating-system/unit07/image1.png" width="100%">

**시작/종료 시간**

- P1: 시작 0, 종료 6 | P2: 시작 6, 종료 8 | P3: 시작 8, 종료 12

**대기시간(WT = 시작 − 도착)**

- P1: 0 − 0 = 0 | P2: 6 − 2 = 4 | P3: 8 − 4 = 4

**반환시간(TAT = 종료 − 도착)**

- P1: 6 − 0 = 6 | P2: 8 − 2 = 6 | P3: 12 − 4 = 8

**평균 대기시간**

- (0+4+4)/3=8/3=2.67

<br>

**SJF (Shortest Job First)**

**CPU 실행 시간이 가장 짧은** 프로세스가 먼저 실행된다.

- **비선점형 스케줄링 알고리즘**이기 때문에 컨텍스트 스위칭 오버헤드가 작다.
- **이론적으로 평균 대기 시간이 최소**다. 하지만 CPU 실행 시간을 예측하기 어려워 사용하기 힘들다.
- CPU 실행 시간이 긴 프로세스는 계속 실행이 연기될 수 있다. **starvation(기아) 발생**

       → **HRN**은 이를 해결하기 위해 만들어진 알고리즘이다.

<img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/operating-system/unit07/image2.png" width="100%">

**시작/종료 시간**

- P2: 시작 0, 종료 2 | P3: 시작 2, 종료 6 | P1: 시작 6, 종료 12

**대기시간 (WT = 시작 − 도착)**

- P2: 0 − 0 = 0 | P3: 2 − 0 = 2 | P1: 6 − 0 = 6

**반환시간 (TAT = 종료 − 도착)**

- P2: 2 − 0 = 2 | P3: 6 − 0 = 6 | P1: 12 − 0 = 12

**평균 대기시간**

- (0 + 2 + 6) / 3 = 8 / 3 = 2.67

<br>

**HRN(Highest Response Ratio Next)**

**SJF**에서 발생하는 **기아 현상을 해결**하기 위해 만들어진 **비선점형 스케줄링 알고리즘**이다.

대기 시간과 CPU 실행 시간을 고려하여 스케줄링한다.

우선 순위는 아래 수식으로 계산한다. 

$응답률(우선순위) = \frac{대기 시간 + CPU 사용 시간}{CPU 사용 시간}$

- 매번 응답률을 계산해야 하므로 복잡해질 수 있다.
- 주로 비실시간 시스템에 사용된다.

<br>

**SRTF (Shortest Remaining Time First)**

**SJF의 선점형 버전**으로 **남은 실행 시간이 가장 짧은 프로세스**가 먼저 실행된다.

- **starvation(기아) 발생할 수 있다.**

<img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/operating-system/unit07/image3.png" width="100%">

**시작/종료 시간**

- P1: 시작 0, 종료 2 | P2: 시작 2, 종료 4 | P1: 시작 4, 종료 8 | P3: 시작 8, 종료 12

**대기시간 (WT = TAT − BT)**

- P1: (8 − 0) − 6 = 2 | P2: (4 − 2) − 2 = 0 | P3: (12 − 4) − 4 = 4

**반환시간 (TAT = 종료 − 도착)**

- P1: 8 − 0 = 8 | P2: 4 − 2 = 2 | P3: 12 − 4 = 8

**평균 대기시간**

- (2 + 0 + 4) / 3 = 2.00

<br>

**Priority**

**각 프로세스에 우선순위를 부여**하여 **우선순위가 높은 프로세스를 먼저 실행**한다.

- 우선순위를 어떻게 부여하느냐에 따라 **선점형 / 비선점형 모두 가능**
- 낮은 우선순위 프로세스의 실행이 계속 연기될 수 있다. **starvation(기아) 발생**

      → 이를 해결하기 위해 **aging 기법 도입**, 대기 시간이 길어질수록 나이를 먹는 것으로 우선순위가 증가된다. 

**선점형 예시**

<img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/operating-system/unit07/image4.png" width="100%">

**시작/종료 시간**

- P1: 시작 0, 종료 2 | P2: 시작 2, 종료 4 | P3: 시작 4, 종료 8 | P1: 시작 8, 종료 12

**대기시간 (WT = TAT − BT)**

- P1: (12 − 0) − 6 = 6 | P2: (4 − 2) − 2 = 0 | P3: (8 − 4) − 4 = 0

**반환시간 (TAT = 종료 − 도착)**

- P1: 12 − 0 = 12 | P2: 4 − 2 = 2 | P3: 8 − 4 = 4

**평균 대기시간**

- (6 + 0 + 0) / 3 = 2.00

**비선점형 예시**

<img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/operating-system/unit07/image5.png" width="100%">

**시작/종료 시간**

- P1: 시작 0, 종료 6 | P2: 시작 6, 종료 8 | P3: 시작 8, 종료 12

**대기시간 (WT = 시작 − 도착)**

- P1: 0 − 0 = 0 | P2: 6 − 2 = 4 | P3: 8 − 4 = 4

**반환시간 (TAT = 종료 − 도착)**

- P1: 6 − 0 = 6 | P2: 8 − 2 = 6 | P3: 12 − 4 = 8

**평균 대기시간**

- (0 + 4 + 4) / 3 = 2.67

<br>

**Round Robin (RR)**

각 프로세스에 동일한 **Time Slice(또는 Time Quantum)를 부여**하고 **Time Slice 만료 시** 프로세스는 **Ready Queue 맨 뒤로 이동**하는 **선점형 스케줄링**이다.

- Ready Queue를 순환 큐(Circular Queue)로 관리
- 응답 시간이 보장된다. (n개 프로세스, 시간 할당량 q일 때, 최대 대기 시간 = (n-1) × q)
- 대화형 시스템에 적합하다.
- **Time Slice 선택 :**
    - 너무 크면 → FCFS와 유사
    - 너무 작으면 → 컨텍스트 스위칭 오버헤드가 크다.
    - ex) Time Slice = 4ms
        - P1: Burst Time = 12ms
        - P2: Burst Time = 8ms
        - P3: Burst Time = 3ms
        
        실행 순서: P1(4) → P2(4) → P3(3) → P1(4) → P2(4) → P1(4)

<br>        

**MLQ(Multi-Level Queue)**

프로세스를 **작업 별 여러 큐로 분류** (ex: 시스템, 대화형 등)하고 **각 큐는 독립적인 스케줄링 알고리즘을 사용**한다.

- 큐 간 **우선순위** 존재
- 프로세스는 최초 배정된 큐를 벗어날 수 없음
- 우선순위가 높은 경우에는 응답이 빠르지만 낮은 경우에는 **starvation** 현상 발생
- 여러 큐 관리 등으로 **스케줄링 오버헤드**가 발생

<br>

**MLFQ(Multi-Level Feedback Queue)**

**큐 간 이동이 허용된 MLQ**이며 **동적으로 우선순위를 조정**할 수 있는 **선점형 스케줄링 알고리즘**이다.

프로세스는 **항상 가장 높은 우선순위 큐에서 시작**하며 각 큐에 **할당된 Time Slice를 모두 사용하면 하위 큐로 이동**된다.

- CPU Burst는 낮은 우선순위의 큐, I/O Burst는 높은 우선순위의 큐에 배치
- 가장 하위 큐는 **FCFS** 스케줄링 알고리즘 사용
- 단계가 내려갈수록 **Time Slice 증가**
- 가장 하위 큐에서 너무 오래 대기할 경우 **aging 기법**을 통해 상위 큐로 이동. **starvation 방지**

💡 CPU Brust : CPU 명령을 실행하는 것 | I/O Burst : I/O 입력을 대기하는 것

<br>

### 4. 스케줄링 성능 평가

|  | 정의 | 수식 |
| --- | --- | --- |
| CPU 사용률 | CPU가 실제로 작업한 시간 비율 |  |
| 처리량 | 단위 시간당 완료된 프로세스 수 |  |
| 반환 시간 | 프로세스 제출부터 완료까지 총 시간 | 대기 시간 + 실행 시간 + I/O 시간 |
| 대기 시간 | Ready Queue에서 대기한 총 시간 |  |
| 응답 시간 | 요청(또는 프로세스 제출) 후 첫 응답(첫 실행)까지 시간 |  |