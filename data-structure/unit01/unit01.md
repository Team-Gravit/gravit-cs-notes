## 배열(Array)

**논리적 저장 순서**와 **물리적 저장 순서**가 일치하는 기본 자료구조. **인덱스**를 통한 **O(1)** 접근이 가능하지만, 삽입/삭제 시 원소 이동으로 인해 **O(n)** 의 비용이 발생한다.

<img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/data-structure/unit01/image.png" width="100%">

### 1. 특징

- **배열**는 메모리 상에서 **연속된 공간**에 데이터를 순차적으로 저장
- 각 원소는 **0**부터 시작하는 **인덱스**로 식별
- 인덱스를 통해 특정 원소에 **직접 접근**(Random Access) 가능

<br>

### 2-1. 배열의 장점

- **인덱스**를 통한 빠른 접근 (O(1))
- **연속된 메모리** 배치로 **캐시 지역성**(Cache Locality) 활용 가능
- 구조가 단순하여 구현과 사용이 간단

<br>

### 2-2. 배열의 단점

- **고정된 크기** (생성 시 크기 지정 필요)
- 삽입/삭제 시 원소 이동으로 인한 **오버헤드**
- 메모리 낭비 가능성 (사용하지 않는 공간도 할당)

<br>

### 3. 배열의 원소 삽입 과정

배열 중간에 원소를 삽입하려면 **삽입 위치 이후의 모든 원소를 오른쪽으로 이동**해야 한다.

```
[1, 2, 3, 4, 5]     # 원본

      ↓ 삽입 위치 기준 오른쪽 원소 한 칸씩 이동

[_, 1, 2, 3, 4, 5]  # 이동 완료

      ↓ '0' 삭제

[0, 1, 2, 3, 4, 5]  # 삽입 완료
```

❗️**최악의 경우**: 첫 번째 위치에 삽입 시, 모든 원소 이동

<br>

### 4. 배열의 원소 삭제 과정

배열 중간의 원소를 삭제하면 **연속성**을 유지하기 위해 뒤의 모든 원소를 왼쪽으로 이동해야 한다.

```
[1, 2, 3, 4, 5]  # 원본

      ↓ '3' 삭제

[1, 2, _, 4, 5]  # 빈 공간 발생

      ↓ '4', '5' 이동

[1, 2, 4, 5]     # 이동 완료
```

❗️**최악의 경우**: 첫번째 위치의 원소 삭제 시, 모든 원소 이동

<br>

### 5. 임의 접근(Random Access)

배열의 각 원소는 **연속된 메모리 주소**에 저장된다. 특정 인덱스의 메모리 주소는 다음과 같이 계산된다.

```
주소 = 배열의 시작 주소 + (인덱스 × 원소의 크기)
```

<br>

**예시**

```
# 배열의 시작 주소가 1000이고, 각 원소가 4바이트라면
# arr[0]: 1000 + (0 × 4) = 1000
# arr[1]: 1000 + (1 × 4) = 1004
# arr[2]: 1000 + (2 × 4) = 1008
```

이 계산은 **산술 연산** 한 번으로 가능하므로 **O(1)** 시간에 접근할 수 있다.

<br>

### 6. 연결리스트와 비교

| **연산**         | **시간 복잡도** | **설명**                        |
| ---------------- | --------------- | ------------------------------- |
| **접근(Access)** | O(1)            | 인덱스로 직접 접근              |
| **탐색(Search)** | O(n)            | 순차 탐색 필요                  |
| **삽입(Insert)** | O(n)            | 삽입 위치 이후의 모든 원소 이동 |
| **삭제(Delete)** | O(n)            | 삭제 위치 이후의 모든 원소 이동 |

<br>

**배열과 연결리스트 선택 기준**

- **조회**가 빈번한 상황 → **배열**
- **삽입**/삭제가 빈번한 상황 → **연결리스트**

<br>

### 7. 배열의 한계

배열은 **연속된 메모리 공간**을 요구하므로 생성 시 정해진 크기를 변경할 수 없다.

**크기 확장이 필요한 경우**

```java
// 기존 배열
int[] arr = new int[5];

// 크기 확장 방법: 새 배열 생성 + 복사
int[] newArr = new int[10];
for (int i = 0; i < arr.length; i++) {
    newArr[i] = arr[i];  // O(n) 복사
}

arr = newArr;
```

<br>

> 💡 Python의 **list**와 Java의 **ArrayList**는 내부적으로 고정 크기 배열을 사용하지만, 용량이 부족할 경우 자동으로 더 큰 배열을 생성하고 기존 원소를 복사하여 동적 크기 조정을 지원한다.

<br>

### 8. 배열과 캐시 지역성

배열은 메모리에 **연속적**으로 저장되어 **캐시 효율성**이 높다.

```python
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
for num in arr:
    print(num)
```

<br>

배열의 요소들은 메모리 상에서 연속된 영역에 위치한다. 이 때 CPU가 특정 요소에 접근하며 **인접한 메모리 영역을 함께 로드**하기 때문에 성능상 이점을 얻을 수 있으며, 이를 **캐시 지역성이 좋다**고 한다.
