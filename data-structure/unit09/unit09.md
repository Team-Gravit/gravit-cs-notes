## 해시테이블(Hash Table)

해시 테이블은 **키**(Key)와 **값**(Value)을 저장하는 자료구조로, **해시 함수**를 이용해 키를 인덱스로 변환하고 그 위치에 값을 저장함으로써 데이터를 빠르게 **검색**/**삽입**/**삭제**할 수 있다.

![image.png](image.png)

<br>

### 1. 특징

- 내부적으로 배열 기반이므로 인덱스 범위는  **0부터 테이블 크기 - 1**까지다.
- 키와 해시 함수를 이용해 데이터의 저장 위치를 계산하기에 평균적으로 **삽입**/**삭제**/**검색** 연산이 O(1)의 시간 복잡도를 가진다.
- 데이터가 저장되는 위치를 **버킷**, **슬롯**이라 한다.

<br>

### 2-1. 해시테이블의 장점

- 데이터에 빠르게 접근할 수 있다.
- 대용량 데이터 관리에 효과적이다.
- 다양한 형태의 키로 데이터에 접근 가능하다.

<br>

### 2-2. 해시테이블의 단점

- 서로 다른 키가 같은 해시 값을 가지면 충돌이 일어난다.
- 데이터의 저장 순서가 유지되지 않는다.
- 해시 함수 품질에 따라 성능이 달라진다.

<br>

### 3. 동작 순서

1. **키**를 **해시 함수**에 전달해 해시 값을 계산한다.
2. **해시 함수**를 통해 얻은 ****해시 값을 이용해 테이블 내의 **인덱스**를 결정한다.

   ex) `index = hash(key) % table_size`

3. 계산된 인덱스 위치에 값을 저장하거나 **충돌 시 다른 슬롯에 저장**한다.
4. 데이터를 검색할 때도 동일한 해시 함수를 사용하여 인덱스를 찾아간다.

<br>

### 4. 시간 복잡도

충돌이 발생하면 버켓 안의 모든 값을 조사해야 한다.

| **연산** | 평균 | 최악(충돌 발생) |
| --- | --- | --- |
| **탐색** | O(1) | O(n) |
| **삽입** | O(1) | O(n) |
| **삭제** | O(1) | O(n) |

<br>

### 5-1. 충돌 처리 전략 - 개별 체이닝(**Separate Chaining**)

충돌 시, 같은 인덱스에 여러 데이터를 **연결리스트나 트리 형태로 저장**하는 전략

<br>

**개별 체이닝 방식의 장점**

- 구현이 간단하고 충돌이 많아도 데이터 저장이 가능하다.
- 테이블 확장이 자유롭다.

<br>

**개별 체이닝 방식의 단점**

- 연결 리스트 길이가 길어지면 성능이 O(n)까지 떨어진다.
- 추가 메모리 사용이 필요하다.

<br>

---

### **5-3. 충돌 처리 전략 - 개방 주소법(Open Addressing)**

충돌 시, 테이블 내 **다른 빈 공간을 탐사해 저장**하는 전략으로 3가지 탐사 방식이 존재한다.

<br>

**선형 탐사(Linear Probing)**

**한 칸씩** 순서대로 다음 칸을 검사해서 비어 있으면 저장한다.

- **장점:** 구현이 간단하다.
- **단점:** 연속된 칸이 채워지는 **클러스터링(Clustering)** 현상이 발생한다.

<br>

**이차 탐사(Quadratic Probing)**

**제곱수 단위**로 건너뛰며 빈 공간을 탐색한다.

- **장점:** 클러스터링이 완화된다.
- **단점:** 특정 패턴의 빈 공간을 건너뛰어 일부 칸이 활용되지 않을 수 있다.

<br>

**이중 해싱(Double Hashing)**

**두 번째 해시 함수를 사용**해서 이동 폭을 다르게 지정한다.

- **장점:** 충돌이 매우 적고 분포가 균등하다.
- **단점:** 구현이 복잡하고 두 개의 좋은 해시 함수가 필요하다.