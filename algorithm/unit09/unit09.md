## 퀵 정렬(Quick Sort)

**분할 정복** 알고리즘 기반 정렬 방식. **피벗(Pivot)** 을 기준으로 배열을 **비균등 분할**하며, **제자리 정렬**이 가능하다. 평균적으로 **O(n log n)** 시간 복잡도를 가지지만, 최악의 경우 **O(n²)** 으로 저하된다.

<br>

### 1. 특징

- **분할 정복** 방식으로 피벗을 기준으로 배열을 비균등하게 분할
- **제자리 정렬**(In-place Sort) 가능, 추가 메모리 공간 최소화
- **불안정 정렬**(Unstable Sort), 동일 값의 순서가 바뀔 수 있음
- 평균적으로 다른 O(n log n) 알고리즘보다 빠름
- **캐시 효율성**이 높아 실무에서 많이 사용됨

<br>

### 2. 동작 과정

**분할(Divide)**

피벗을 선택하고, 피벗보다 작은 원소는 왼쪽, 큰 원소는 오른쪽으로 배치하여 배열을 2개의 부분 배열로 분할한다.

<br>

**정복(Conquer)**

분할된 부분 배열에 대해 재귀적으로 퀵 정렬을 반복한다.

<br>

**결합(Combine)**

정렬된 부분 배열을 하나로 합친다. 별도 병합 과정은 불필요하다.

<br>

### 3. 동작 예시

```
[5, 3, 8, 4, 9, 1, 6, 2, 7]  # 피벗 = 5

      ↓ 피벗 기준 분할

[3, 4, 1, 2] [5] [8, 9, 6, 7]

      ↓ 재귀 정렬

[1, 2, 3, 4, 5, 6, 7, 8, 9]

```

<br>

### 4. 분할(Partition) 과정

피벗을 기준으로 배열을 분할하는 과정은 **두 개의 포인터(low, high)** 를 사용한다.

```
[5, 3, 8, 4, 9, 1, 6, 2, 7]  피벗 = 5
 ↑                       ↑
low                     high

1) low: 왼쪽→오른쪽, 피벗보다 큰 값 탐색
2) high: 오른쪽→왼쪽, 피벗보다 작은 값 탐색
3) 두 값 교환
4) low > high 될 때까지 반복

         ↓

[1, 3, 2, 4, 5, 9, 6, 8, 7]  분할 완료
             ↑
           피벗 확정

```

<br>

### 5. 피벗(Pivot) 선택 전략

| **전략** | **특징** |
| --- | --- |
| **첫/마지막 원소** | 구현 간단, 정렬된 배열에 취약 |
| **중간 원소** | 균등 분할 가능성 증가 |
| **무작위 선택** | 최악의 경우 확률 감소 |
| **중앙값(Median)** | 최적 분할, 연산 비용 증가 |

<br>

### 6. 시간 복잡도

| **경우** | **시간 복잡도** | **조건** |
| --- | --- | --- |
| **최선/평균** | O(n log n) | 균등 분할 |
| **최악** | O(n²) | 정렬된 배열 + 첫/끝 피벗 |

<br>

### 7. 공간 복잡도

- **제자리 정렬**: O(log n) - 재귀 호출 스택
- **최악의 경우**: O(n) - 한쪽으로만 분할 시 재귀 깊이 n

<br>

### 8. 구현

```python
def quick_sort(arr, left, right):
    if left >= right:  # 기저 조건
        return

    pivot = partition(arr, left, right)  # 분할
    quick_sort(arr, left, pivot - 1)     # 왼쪽 정렬
    quick_sort(arr, pivot + 1, right)    # 오른쪽 정렬

def partition(arr, left, right):
    pivot = arr[left]  # 첫 원소를 피벗으로 선택
    low, high = left, right

    while low < high:
        # 피벗보다 작은 값 찾기
        while low < high and arr[high] >= pivot:
            high -= 1
        # 피벗보다 큰 값 찾기
        while low < high and arr[low] <= pivot:
            low += 1

        arr[low], arr[high] = arr[high], arr[low]  # 교환

    arr[left], arr[low] = arr[low], arr[left]  # 피벗을 최종 위치로
    return low

```

<br>

### 9. 퀵 정렬의 장점

- **빠른 속도**: 평균적으로 O(n log n) 알고리즘 중 가장 빠름
- **캐시 효율성**: 인접 데이터 비교로 캐시 히트율이 높음
- **제자리 정렬**: 추가 메모리 공간 최소화

<br>

### 10. 퀵 정렬의 단점

- **최악의 경우 O(n²)**: 정렬된 배열에서 첫/끝 피벗 선택 시 성능 저하
- **불안정 정렬**: 동일 값의 순서가 보장되지 않음
- **재귀 오버헤드**: 재귀 호출로 인한 스택 사용

<br>

### 11. 병합 정렬(Merge Sort)과 비교

| **특징** | **퀵 정렬** | **병합 정렬** |
| --- | --- | --- |
| **분할 방식** | 비균등 분할 (피벗) | 균등 분할 (중간) |
| **추가 메모리** | O(log n) | O(n) |
| **안정성** | 불안정 | 안정 |
| **평균 속도** | 더 빠름 | 느림 |
| **최악의 경우** | O(n²) | O(n log n) |

<br>

### 12. 최적화 전략

**피벗 선택 개선** 

중앙값(Median-of-Three) 방식으로 첫/중간/끝 원소 중 중앙값을 피벗으로 선택하여 최악의 경우 발생 확률을 줄일 수 있다.

<br>

**작은 배열 처리**

배열 크기가 일정 수준(약 10개) 이하일 때 삽입 정렬로 전환하여 재귀 오버헤드를 줄일 수 있다.

<br>

**꼬리 재귀 최적화**

한쪽 부분 배열을 재귀 호출 대신 반복문으로 처리하여 스택 깊이를 줄일 수 있다.