# 삽입 정렬(Insertion Sort)

**정렬된 부분**과 **정렬되지 않은 부분**으로 나누어, 정렬되지 않은 부분에서 원소를 하나씩 꺼내 **정렬된 부분의 올바른 위치에 삽입**하는 알고리즘. 손안의 카드를 정렬하는 방법과 유사하며, **거의 정렬된 데이터**에서 **O(n)** 의 효율적인 성능을 보인다.

<br>

### 1. 특징

- 배열을 **정렬된 부분**과 **정렬되지 않은 부분**으로 구분
- 정렬되지 않은 부분에서 원소를 하나씩 선택하여 **삽입**
- 정렬된 부분의 **맨 뒤 원소부터** 비교하며 적절한 위치를 찾음
- **안정 정렬**(Stable Sort) - 동일한 값의 순서 유지
- **거의 정렬된 배열**에서 매우 효율적 (O(n))

<br>

### 2. 정렬 과정

N개의 원소가 있을 때, 삽입 정렬은 다음과 같이 작동한다.

1. 배열의 첫 번째 요소는 정렬이 되어 있다고 가정하고, 두 번째 요소부터 시작한다.
2. 정렬되지 않은 부분의 첫 번째 요소를 **현재 요소**로 선택한다.
3. **현재 요소**를 정렬된 부분의 요소들과 **뒤에서부터** 차례대로 비교한다.
4. **현재 요소**보다 큰 요소들을 **오른쪽으로 한 칸씩 이동**시킨다.
5. **현재 요소**보다 작거나 같은 요소를 만나면, 그 **오른쪽 위치에 현재 요소를 삽입**한다.

<br>

### 3. 정렬 과정 예시

**1회전**

두 번째 원소 `25`를 정렬된 부분 [64]와 비교한다. `25`가 `64`보다 작으므로 `64`를 오른쪽으로 한 칸 이동하고 `25`를 첫 번째 위치에 삽입한다.

<img src="image1.png" width="100%">

<br>

**2회전**

세 번째 원소 `12`를 정렬된 부분 `[25 64]`와 비교한다. `12`가 `64`, `25`보다 모두 작으므로 두 원소를 오른쪽으로 한 칸씩 이동하고 `12`를 첫 번째 위치에 삽입한다.

<img src="image2.png" width="100%">

<br>

**3회전**

네 번째 원소 `22`를 정렬된 부분 `[12 25 64]`와 비교한다. `22`는 `12`보다 크고 `25`보다 작으므로 `64`, `25`를 오른쪽으로 이동하고 22를 두 번째 위치에 삽입한다.

<img src="image3.png" width="100%">

<br>

**4회전**

마지막 원소 `11`을 정렬된 부분 `[12 22 25 64]`와 비교한다. `11`이 모든 원소보다 작으므로 모든 원소를 오른쪽으로 이동하고 `11`을 첫 번째 위치에 삽입한다.

<img src="image4.png" width="100%">

<br>

### 4. 시간 복잡도

| **케이스** | **시간 복잡도** | **설명** |
| --- | --- | --- |
| **최선(Best)** | O(n) | 이미 정렬된 경우, 비교만 수행 |
| **평균(Average)** | O(n²) | 일반적인 경우 |
| **최악(Worst)** | O(n²) | 역순으로 정렬된 경우 |

<br>

**비교 횟수**

- **최선의 경우**: **n-1**번(각 원소당 1번씩만 비교)
- **최악의 경우**: **n(n-1)/2** 번

<br>

**교환(이동) 횟수**

- **최선의 경우**: **0**번(이미 정렬된 경우)
- **최악의 경우**: 비교 횟수와 동일

<br>

### 5-1. 삽입 정렬의 장점

- 구현이 **간단**하고 직관적
- **거의 정렬된 배열**에서 매우 효율적 (O(n))
- **제자리 정렬**(in-place sorting) - 추가 메모리 불필요
- **안정 정렬**(Stable Sort) - 동일한 값의 순서 유지

<br>

### 5-2. 삽입 정렬의 단점

- **평균/최악 시간 복잡도**가 O(n²)로 비효율적
- **역순 정렬 배열**에서 매우 느림

<br>

### 6. 다른 정렬 알고리즘과 비교

| **정렬 알고리즘** | **최선** | **평균** | **최악** | **안정성** | **특징** |
| --- | --- | --- | --- | --- | --- |
| **삽입 정렬** | **O(n)** | **O(n²)** | **O(n²)** | **✓** | **거의 정렬된 데이터에 강함** |
| **버블 정렬** | O(n²) | O(n²) | O(n²) | ✓ | 교환이 빈번함 |
| **선택 정렬** | O(n²) | O(n²) | O(n²) | ✗ | 교환 횟수 적음 |
| **퀵 정렬** | O(n log n) | O(n log n) | O(n²) | ✗ | 평균적으로 가장 빠름 |
| **병합 정렬** | O(n log n) | O(n log n) | O(n log n) | ✓ | 추가 메모리 필요 |

<br>

> 💡 **삽입 정렬**은 거의 정렬된 데이터나 작은 배열에서 매우 효율적이다. 실제로 TimSort(Python, Java 기본 정렬)와 IntroSort(C++ STL)는 작은 부분 배열에서 삽입 정렬을 사용한다. 하지만 큰 무작위 배열에는 퀵 정렬이나 병합 정렬이 더 적합하다.
