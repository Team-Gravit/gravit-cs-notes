## 1. 깊이 우선 탐색(DFS, Depth-First Search)

갈 수 있는 곳까지 최대한 깊이 들어가고, 더 이상 갈 곳이 없으면 이전 정점으로 돌아가 다른 경로를 탐색하는 방식이다. **스택** 또는 **재귀 함수**로 구현한다.

<br>

### 1-1. 특징

- 한 방향으로 끝까지 탐색 후 다른 방향 탐색
- 스택(Stack) 또는 재귀 함수 사용
- 백트래킹(Backtracking) 방식
- 모든 경로를 탐색해야 하는 문제에 유리함
- 구현이 BFS보다 간단함

<br>

### 1-2. 동작 과정

```
    1
   / \
  2   3
 / \   \
4   5   6

DFS 탐색 순서 (재귀, 왼쪽 우선):
1 → 2 → 4 → 5 → 3 → 6

```

<br>

**알고리즘**

시작 정점을 방문 처리하고 스택에 삽입한다. 스택에서 원소를 꺼내어 인접 정점 중 방문하지 않은 정점을 방문 처리하고 스택에 삽입한다. 스택이 빌 때까지 반복한다.

<br>

### 1-3. 상세 예시

```
    A
   / \
  B   C
 /|   |\
D E   F G

단계별 진행:
[1] A 방문 → 스택: [A]
[2] A의 인접 노드 B 방문 → 스택: [A, B]
[3] B의 인접 노드 D 방문 → 스택: [A, B, D]
[4] D는 더 이상 갈 곳 없음 → 스택: [A, B]
[5] B의 인접 노드 E 방문 → 스택: [A, B, E]
[6] E는 더 이상 갈 곳 없음 → 백트래킹
[7] A의 인접 노드 C 방문 → 스택: [A, C]
[8] C의 인접 노드 F, G 순차 방문 → 탐색 종료

```

<br>

### 1-4. 시간 복잡도

| **그래프 표현** | **시간 복잡도** |
| --- | --- |
| **인접 행렬** | O(V²) |
| **인접 리스트** | O(V + E) |

V: 정점(Vertex) 개수, E: 간선(Edge) 개수

<br>

### 1-5. 공간 복잡도

- **재귀 구현**: O(V) - 재귀 호출 스택의 최대 깊이
- **스택 구현**: O(V) - 명시적 스택의 크기
- **최악의 경우**: 그래프가 선형 구조일 때 O(V)

<br>

### 1-6. 구현

**재귀 방식**

```python
def dfs_recursive(graph, v, visited):
    visited[v] = True
    print(v, end=' ')

    for next_v in graph[v]:
        if not visited[next_v]:
            dfs_recursive(graph, next_v, visited)

```

<br>

**스택 방식**

```python
def dfs_stack(graph, start):
    visited = set()
    stack = [start]

    while stack:
        v = stack.pop()

        if v not in visited:
            visited.add(v)
            print(v, end=' ')

            # 역순으로 추가하여 작은 번호부터 방문
            for next_v in sorted(graph[v], reverse=True):
                if next_v not in visited:
                    stack.append(next_v)

```

<br>

### 1-7. DFS의 장점

- 구현이 간단함 (특히 재귀 방식)
- 현재 경로상의 노드만 기억하므로 메모리 효율적
- 모든 경로를 탐색해야 하는 문제에 적합함
- 백트래킹 기법과 함께 사용하기 용이함

<br>

### 1-8. DFS의 단점

- 최단 경로를 보장하지 않음
- 무한 깊이 주의 필요 (깊이 제한 없으면 무한 루프 가능)

<br>

### 1-9. 활용 사례

- **경로 탐색**: 미로 찾기, 퍼즐 게임
- **사이클 검출**: 그래프에 사이클이 있는지 확인
- **위상 정렬**: 선수 과목, 작업 순서 결정
- **연결 요소 찾기**: 단지 번호 붙이기, 섬의 개수
- **백트래킹 문제**: N-Queen, 조합, 순열

<br>

## 2. 너비 우선 탐색(BFS, Breadth-First Search)

시작 정점에서 가까운 정점부터 차례대로 탐색하는 방식이다. 같은 깊이(레벨)에 있는 노드를 모두 탐색한 후 다음 깊이로 넘어간다. **큐(Queue)** 를 사용하여 구현한다.

<br>

### 2-1. 특징

- 레벨 순서대로 탐색 (가까운 노드부터)
- 큐(Queue) 사용
- 최단 거리를 보장함 (가중치가 없는 그래프)
- 시작점으로부터의 거리(레벨) 계산 가능
- 메모리 사용량이 DFS보다 많을 수 있음

<br>

### 2-2. 동작 과정

```
    1
   / \
  2   3
 / \   \
4   5   6

BFS 탐색 순서: 1 → 2 → 3 → 4 → 5 → 6

레벨별:
Level 0: 1
Level 1: 2, 3
Level 2: 4, 5, 6

```

<br>

**알고리즘**

시작 정점을 방문 처리하고 큐에 삽입한다. 큐에서 원소를 꺼내어 인접한 칸 중 방문하지 않은 칸을 방문 처리하고 큐에 삽입한다. 큐가 빌 때까지 반복한다.

<br>

### 2-3. 상세 예시

```
    A
   / \
  B   C
 /|   |\
D E   F G

방문 순서: A → B → C → D → E → F → G

단계별 진행 (큐 상태):
[1] 시작: A 방문, 큐: [A]
[2] A 꺼냄, B와 C 추가: 큐: [B, C]
[3] B 꺼냄, D와 E 추가: 큐: [C, D, E]
[4] C 꺼냄, F와 G 추가: 큐: [D, E, F, G]
[5] D, E, F, G 순차 처리 → 탐색 종료

레벨별:
- Level 0: A
- Level 1: B, C
- Level 2: D, E, F, G

```

<br>

### 2-4. 시간 복잡도

| **그래프 표현** | **시간 복잡도** |
| --- | --- |
| **인접 행렬** | O(V²) |
| **인접 리스트** | O(V + E) |

V: 정점(Vertex) 개수, E: 간선(Edge) 개수

<br>

### 2-5. 공간 복잡도

- **큐 크기**: O(V) - 최악의 경우 모든 정점이 큐에 저장
- **방문 배열**: O(V)
- **최악의 경우**: 완전 그래프에서 O(V)

<br>

### 2-6. 구현

```python
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)

    while queue:
        v = queue.popleft()
        print(v, end=' ')

        for next_v in sorted(graph[v]):
            if next_v not in visited:
                visited.add(next_v)
                queue.append(next_v)

# 사용 예시
graph = {
    1: [2, 3],
    2: [1, 4, 5],
    3: [1, 6],
    4: [2],
    5: [2],
    6: [3]
}
bfs(graph, 1)  # 1 2 3 4 5 6
```

<br>

### 2-7. BFS의 장점

- 최단 경로를 보장함 (가중치가 없는 그래프)
- 레벨별 탐색이 명확하여 특정 깊이까지만 탐색 가능

<br>

### 2-8. BFS의 단점

- 메모리 사용량이 많음 (큐에 많은 노드 저장 가능)
- 경로의 특징을 저장하기 어려움
- 재귀 구현 불가 (큐 사용 필수)

<br>

### 2-9. 활용 사례

- **최단 거리 문제**: 미로 탈출, 최소 이동 횟수
- **레벨별 탐색**: 트리의 레벨 순회, 소셜 네트워크
- **연결 요소 찾기**: 섬의 개수, 영역 구하기
- **가중치 없는 최단 경로**: 게임 맵, 네트워크 라우팅

<br>

## 3. DFS vs BFS 비교

| **특성** | **DFS** | **BFS** |
| --- | --- | --- |
| **탐색 방향** | 깊이 우선 | 너비 우선 |
| **자료구조** | 스택/재귀 | 큐 |
| **시간 복잡도** | O(V + E) | O(V + E) |
| **공간 복잡도** | O(V) | O(V) |
| **최단 경로** | 보장 안 됨 | 보장됨 |
| **메모리 사용** | 적음 | 많음 |
| **목표 위치** | 깊은 곳 유리 | 얕은 곳 유리 |
| **구현 난이도** | 쉬움 | 보통 |
| **모든 경로 탐색** | 유리 | 불리 |