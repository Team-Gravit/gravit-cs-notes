## 그리디 알고리즘(Greedy Algorithm)

그리디 알고리즘은 매 순간 **지금 당장 가장 좋아 보이는 선택**을 하면서 답을 만드는 알고리즘이다.

각 단계에서 **지역 최적**(Local Optimum)을 선택하여 **전역 최적**(Global Optimum)을 기대한다. 빠르고 구현이 단순하지만 **항상 최적해를 보장하지는 않는다**.

<br>

### 1. 그리디 알고리즘 주요 속성

**탐욕 선택 속성(Greedy Choice Property)**

- 각 단계에서 **최선의 선택**을 했을 때 전체 문제의 **최적해**를 구할 수 있는 경우
- 각 단계의 최선 선택이 전체적으로 최적의 결과를 가져옴

<br>

**최적 부분 구조(Optimal Substructure)**

- 전체 문제의 최적해가 **부분 문제의 최적해로 구성**될 수 있는 경우
- 전체 문제를 작은 부분 문제로 나누어 각각 최적해를 구한 후 조합함

<br>

> 그리디 알고리즘이 항상 최적해를 보장하려면 위 두 속성을 모두 만족해야 한다.

<br>

### 2. 그리디 알고리즘 진행 단계

**1. 문제 구조 파악**

- 무엇을 최소화/최대화할 것인지 정함(비용, 개수, 거리 등)
- 선택 단위를 정함(동전 1개, 회의 1개, 간선 1개 등)

<br>

**2. 선택 기준 정의**

- 현재 상태에서 가장 좋은 선택의 기준을 정함
- 코인 문제: 남은 금액을 넘지 않는 가장 큰 동전 선택
- 회의실 배정: 시작 시간이 가장 빠른 회의 선택

<br>

**3. 정렬 또는 우선순위 구조 준비**

- 기준에 맞게 정렬하거나 우선순위 큐(힙)를 사용함

<br>

**4. 반복 선택 및 적절성 검사**

- 가장 좋은 후보를 선택함
- 제약 조건을 위반하지 않는지 확인함
- 조건을 만족하면 해에 포함시키고 아니면 버림

<br>

**5. 해답 검사**

- 더 이상 선택할 것이 없거나 목표 조건을 만족하면 종료함

<br>

### 3. 예시: 코인 거스름돈 문제

**문제**

동전 종류가 **500, 100, 50, 10원**이고 각 동전은 무한히 있다. **1260원**을 거슬러 줄 때 **동전 개수의 최소값**을 구하라.

<br>

**그리디 전략**

남은 금액을 넘지 않는 선에서 가장 큰 동전부터 최대한 많이 사용한다.

<br>

**풀이 과정**

1. **500원**: 1260 / 500 = 2개 → 남은 금액 260원
2. **100원**: 260 / 100 = 2개 → 남은 금액 60원
3. **50원**: 60 / 50 = 1개 → 남은 금액 10원
4. **10원**: 10 / 10 = 1개 → 남은 금액 0원

**총 동전 수**: 6개

<br>

**왜 그리디가 최적인가**

- 500, 100, 50, 10은 모두 작은 동전의 배수 구조
- 큰 동전을 최대한 많이 써도 작은 동전 조합이 더 이득인 경우가 없음
- **탐욕 선택 속성**과 **최적 부분 구조**를 모두 만족함

<br>

### 4. 예시: 회의실 배정

**문제**

여러 회의가 **시작 시간**과 **종료 시간**을 가지며, 하나의 회의실에서는 동시에 두 개 이상의 회의가 진행될 수 없다. 모든 회의를 배치하기 위해 필요한 **회의실의 최소 개수**를 구하라.

| 회의 | 시작 시간 | 종료 시간 |
| ---- | --------- | --------- |
| T1   | 0         | 2         |
| T2   | 1         | 6         |
| T3   | 1         | 5         |
| T4   | 3         | 7         |
| T5   | 5         | 9         |
| T6   | 6         | 8         |
| T7   | 7         | 8         |

<br>

**그리디 전략**

- 모든 회의를 시작 시간 오름차순으로 정렬함
- 현재 회의의 시작 시간보다 이전에 끝난 회의실을 찾음
- 그런 회의실이 있으면 배정하고, 없으면 새 회의실을 생성함

<br>

**동작 흐름**

1. **시작시간이 가장 빠른 T1 먼저 선택 후 회의실 1을 배정한다.**

<img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/algorithm/unit14/image1.png" width="100%">

<br>

2. **다음으로 시작 시간이 빠른 T2 선택 후 회의실 자리를 확인하고 없으면 추가해서 작업을 넣는다.**

<img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/algorithm/unit14/image2.png" width="100%">

<br>

3. **이를 반복하면 다음과 같은 결과를 얻을 수 있다.**

<img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/algorithm/unit14/image3.png" width="100%">

<br>

**풀이 과정**

1. **T1 [0,2]**: 회의실 1 생성
2. **T2 [1,6]**: 회의실 1과 겹침 → 회의실 2 생성
3. **T3 [1,5]**: 회의실 1, 2와 겹침 → 회의실 3 생성
4. **T4 [3,7]**: 회의실 1(2시 종료)에 배정 가능
5. **T5 [5,9]**: 회의실 3(5시 종료)에 배정 가능
6. **T6 [6,8]**: 회의실 2(6시 종료)에 배정 가능
7. **T7 [7,8]**: 회의실 1(7시 종료)에 배정 가능

**최종 결과**: 회의실 3개 필요

<br>

**왜 그리디가 최적인가**

- 어떤 시점에 동시에 진행되는 회의의 최대 개수를 **maxOverlap**이라 하면, 최소 **maxOverlap**개의 회의실이 필요함
- 그리디 알고리즘이 사용하는 회의실 수도 **maxOverlap**이므로 최적임

<br>

### 5. 그리디의 한계

**문제**

동전이 **16원, 5원, 1원**이고 각 동전은 무한히 있다. **20원**을 만들 때 필요한 **동전 개수의 최소값**을 구하라.

<br>

**그리디 전략 적용**

1. **16원** 1개 사용 → 남은 금액 4원
2. **1원** 4개 사용 → 남은 금액 0원

**사용한 동전**: 총 5개

<br>

**실제 최적해**

**5원 동전 4개** 사용 → 총 4개

<br>

**문제점**

- 16원을 먼저 선택하면 남은 4원을 1원으로만 채울 수 있음
- 가장 큰 동전을 먼저 선택하는 것이 전체 최적해의 일부라고 보장할 수 없음
- **탐욕 선택 속성**이 깨지므로 그리디 알고리즘이 최적해를 보장하지 못함
