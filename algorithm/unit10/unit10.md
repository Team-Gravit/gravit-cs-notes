## 힙 정렬(Heap Sort)

**완전 이진 트리** 기반의 **힙(Heap)** 자료구조를 활용하는 정렬 알고리즘. **선택 정렬**의 개선 형태로, **제자리 정렬**이 가능하며 최악의 경우에도 **O(n log n)** 을 보장한다.

<br>

### 1. 특징

- **완전 이진 트리** 기반의 힙 자료구조 활용
- **제자리 정렬**(In-place Sort), 추가 메모리 최소화
- **불안정 정렬**(Unstable Sort), 동일 값의 순서가 바뀔 수 있음
- **최악의 경우에도 O(n log n) 보장** (퀵 정렬과의 주요 차이)
- **우선순위 큐**의 구현 원리와 동일

<br>

### 2. 동작 과정

**힙 구축(Build Heap)**

정렬되지 않은 배열을 최대 힙(Max Heap) 또는 최소 힙(Min Heap)으로 변환한다. 오름차순 정렬은 최대 힙, 내림차순 정렬은 최소 힙을 사용한다.

<br>

**정렬(Sort)**

힙의 루트(최댓값 또는 최솟값)를 배열의 마지막 원소와 교환한 후, 힙 크기를 줄이고 힙을 재구성한다. 배열 크기가 1이 될 때까지 반복한다.

<br>

### 3. 동작 예시

```
[4, 10, 3, 5, 1]  # 원본

      ↓ 최대 힙 구축

       10
      /  \
     5    3
    / \
   4   1

[10, 5, 3, 4, 1]

      ↓ 루트(10)와 마지막(1) 교환

[1, 5, 3, 4, 10]

      ↓ 힙 재구성 (크기: 4)

[5, 4, 3, 1, 10]

      ↓ 반복...

[1, 3, 4, 5, 10]  # 정렬 완료

```

<br>

### 4. 힙 구축(Heapify) 과정

**Heapify**: 특정 노드를 루트로 하는 부분 트리를 힙 속성에 맞게 재구성

```
       4           # 힙 속성 위반
      /  \
     10   3        # 최댓값(10)과 교환
    / \
   5   1

       ↓

       10
      /  \
     4    3        # 여전히 위반
    / \
   5   1

       ↓

       10          # 다시 교환
      /  \
     5    3
    / \
   4   1          # 힙 속성 만족

```

<br>

### 5. 시간 복잡도

| **경우** | **시간 복잡도** |
| --- | --- |
| **최선/평균/최악** | O(n log n) |

<br>

**분석**

- **힙 구축**: O(n) - n/2개 노드에 대해 heapify 수행
- **정렬 단계**: O(n log n) - n-1번 반복, 각 반복마다 heapify O(log n)
- **총 시간 복잡도**: O(n) + O(n log n) = **O(n log n)**

<br>

### 6. 공간 복잡도

- **제자리 정렬**: O(1) - 추가 배열 불필요
- **재귀 구현**: O(log n) - 재귀 호출 스택
- **반복 구현**: O(1) - 스택 공간 불필요

<br>

### 7. 구현

```python
def heapify(arr, n, i):
    """특정 노드를 루트로 하는 부분 트리를 최대 힙으로 재구성"""
    largest = i           # 현재 노드를 최댓값으로 가정
    left = 2 * i + 1      # 왼쪽 자식
    right = 2 * i + 2     # 오른쪽 자식

    # 왼쪽 자식이 더 크면
    if left < n and arr[left] > arr[largest]:
        largest = left

    # 오른쪽 자식이 더 크면
    if right < n and arr[right] > arr[largest]:
        largest = right

    # 최댓값이 현재 노드가 아니면 교환 후 재귀
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    # 1단계: 최대 힙 구축
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # 2단계: 루트를 반복적으로 추출하여 정렬
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]  # 루트와 마지막 교환
        heapify(arr, i, 0)               # 힙 재구성

```

<br>

### 8. 장점

- **안정적 성능**: 최악의 경우에도 O(n log n) 보장
- **제자리 정렬**: 추가 메모리 O(1)
- **예측 가능**: 입력 데이터에 관계없이 일정한 성능
- **최댓값/최솟값 추출**: 가장 큰/작은 값을 빠르게 찾을 때 효율적

<br>

### 9. 단점

- **불안정 정렬**: 동일 값의 순서가 보장되지 않음
- **캐시 지역성 낮음**: 부모-자식 노드 간 메모리 주소가 멀어 캐시 효율 저하
- **실제 수행 시간**: 같은 O(n log n)인 퀵 정렬보다 2~3배 느림

<br>

### 10. 다른 정렬 알고리즘과 비교

| **특징** | **힙 정렬** | **퀵 정렬** | **병합 정렬** |
| --- | --- | --- | --- |
| **평균 시간** | O(n log n) | O(n log n) | O(n log n) |
| **최악 시간** | O(n log n) | O(n²) | O(n log n) |
| **공간 복잡도** | O(1) | O(log n) | O(n) |
| **안정성** | 불안정 | 불안정 | 안정 |
| **수행 속도** | 느림 | 빠름 | 보통 |
| **적합 상황** | 최악 보장 필요 | 평균 케이스 | 안정 정렬 필요 |