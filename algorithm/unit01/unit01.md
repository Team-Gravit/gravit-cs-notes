## 시간 복잡도와 Big-O 표기법

**시간 복잡도**는 알고리즘이 문제를 해결하는 데 걸리는 시간을 입력 크기 **n**의 함수로 나타낸 것이다. 입력이 커질수록 실행 시간이 얼마나 증가하는지 예측할 수 있다.

<br>

그 중 **Big-O 표기법**은 입력 크기 **n**이 커질 때, 알고리즘이 수행하는 연산 수의 **상한**(최악의 경우)을 표현한다.

<br>

### 1. 시간 복잡도 종류

| 표기 | 이름 | 설명 | 예시 |
| --- | --- | --- | --- |
| **O(1)** | 상수 시간 | 입력 크기와 상관없이 일정한 시간 | 배열 인덱스 접근, 해시 조회 |
| **O(log n)** | 로그 시간 | 매 단계마다 입력을 절반으로 줄임 | 이진 탐색, 힙 연산 |
| **O(n)** | 선형 시간 | 입력 개수만큼 순회 | 단순 반복문, 선형 탐색 |
| **O(n log n)** | 선형로그 시간 | 선형과 로그의 복합 | 병합 정렬, 퀵 정렬(평균) |
| **O(n²)** | 제곱 시간 | 이중 반복문 구조 | 버블 정렬, 선택 정렬 |
| **O(2ⁿ)** | 지수 시간 | 가능한 모든 경우 탐색 | 부분집합 탐색, DFS 완전탐색 |
| **O(n!)** | 팩토리얼 시간 | 모든 순열 탐색 | 외판원 문제(TSP) |
- 위로 갈수록 효율적, 아래로 갈수록 비효율적
- 현실적으로 **O(n log n)** 이하의 복잡도만 실용적

<br>

### 2. 시간 복잡도별 실행 횟수 비교

| 입력 크기 (n) | O(n) | O(n log n) | O(n²) | O(2ⁿ) |
| --- | --- | --- | --- | --- |
| **5** | 5 | 11 | 25 | 32 |
| **10** | 10 | 33 | 100 | 1,024 |
| **20** | 20 | 86 | 400 | 1,048,576 |

> ⚠️ 입력이 커질수록 O(1)~O(n log n)은 실용적이지만, O(2ⁿ), O(n!)은 **입력 크기가 조금만 커져도 현실적으로 불가능**해진다.

<br>

### 3. 중요 이유

- 시간 복잡도는 **알고리즘의 효율성을 정량적으로 비교**하기 위한 기준이다.
- 같은 기능을 수행하더라도, **입력 크기(n)** 가 커지면 성능 차이가 급격히 벌어진다.
- 대규모 데이터나 실시간 시스템에서는 **복잡도가 낮은 알고리즘 선택이 필수적**이다.