## 선택 정렬(Selection Sort)

**정렬할 위치는 이미 정해져 있고**, **어떤 원소를 선택**하여 그 위치에 넣을지 결정하는 알고리즘. 매 회전마다 **가장 작은 값**을 찾아 앞쪽의 정해진 위치와 교환한다. 버블 정렬보다 **교환 횟수가 적지만** **O(n²)** 의 비효율적인 시간 복잡도를 가진다.

<br>

### 1. 선택 정렬의 특징

- 매 회전마다 **최솟값을 탐색**하여 정해진 위치에 배치
- 교환 횟수가 **최대 n-1번**으로 제한됨 (버블 정렬보다 적음)
- **불안정 정렬**(Unstable Sort) - 동일한 값의 순서가 바뀔 수 있음

<br>

### 2. 정렬 과정

N개의 원소가 있을 때, 선택 정렬은 다음과 같이 작동한다.

1. 주어진 배열에서 가장 작은 값을 찾아 첫 번째 요소의 값과 교체한다 → 가장 작은 요소가 올바른 위치(첫 번째)에 배치된다.
2. 정렬된 맨 처음 위치를 빼고 나머지 배열을 같은 방법으로 교체한다.
3. 하나의 원소만 남을 때까지 1~3 과정을 반복한다.

<br>

### 3. 정렬 과정 예시

**1회전**

첫 번째 원소 `64`를 두 번째 원소부터 마지막 원소까지와 비교하여 가장 작은 값인 `11`을 첫 번째 위치에 옮겨 놓는다.이 과정에서 원소를 4번 비교한다.

![image1.png](image1.png)

<br>

**2회전**

두 번째 원소 `25`와 세 번째 원소부터 마지막 원소까지 비교하여 가장 작은 값`12`를 찾아 두 번째 위치에 옮겨 놓는다. 이 과정에서 원소를 3번 비교한다.

![image2.png](image2.png)

<br>

**3회전**

세 번째 원소 `25`를 네 번째 원소부터 마지막 원소까지와 비교하여 가장 작은 값`22`를 세 번째 위치에 옮겨 놓는다. 이 과정에서 원소를 2번 비교한다.

![image3.png](image3.png)

<br>

**4회전**

네 번째 원소 `25`와 마지막에 있는 `64`를 비교한다. `25`가 더 작으므로 교환하지 않는다.

![image4.png](image4.png)

<br>

### 4. 시간 복잡도

| **케이스** | **시간 복잡도** | **설명** |
| --- | --- | --- |
| **최선(Best)** | O(n²) | 이미 정렬된 경우에도 모든 비교 수행 |
| **평균(Average)** | O(n²) | 일반적인 경우 |
| **최악(Worst)** | O(n²) | 역순으로 정렬된 경우 |

<br>

**비교 횟수**

모든 경우에서 **n(n-1)/2** 번의 비교를 수행한다.

<br>

**교환 횟수**

- **최선의 경우**: **0**번(이미 정렬된 경우)
- **최악의 경우**: **n-1**번(매 회전마다 1번 교환)

❗️버블 정렬보다 **교환 횟수가 훨씬 적음**

<br>

### 5-1. 선택 정렬의 장점

- 구현이 **간단**하고 이해하기 쉬움
- **교환 횟수가 적음** - 버블 정렬보다 효율적
- **제자리 정렬**(in-place sorting) - 추가 메모리 불필요
- **자료 이동 횟수가 미리 결정됨** (최대 n-1번)

<br>

### 5-2. 선택 정렬의 단점

- **비효율적인 시간 복잡도** (O(n²))
- 정렬 여부와 무관하게 **모든 비교 수행**
- **불안정 정렬**(Unstable Sort) - 동일한 값의 순서가 바뀔 수 있음

<br>

### 6. 불안정 정렬 예시

선택 정렬은 동일한 값의 순서가 바뀔 수 있는 **불안정 정렬**이다.

```
초기 배열: [5₁, 3, 5₂, 1]  (아래 첨자는 구분용)

1회전: 최솟값 1을 찾아 5₁과 교환
→ [1, 3, 5₂, 5₁]  (5₁과 5₂의 순서가 바뀜!)
```

<br>

### 7. 다른 정렬 알고리즘과 비교

| **정렬 알고리즘** | **최선** | **평균** | **최악** | **안정성** | **교환 횟수** |
| --- | --- | --- | --- | --- | --- |
| **선택 정렬** | **O(n²)** | **O(n²)** | **O(n²)** | **✗** | **O(n)** |
| **버블 정렬** | O(n²) | O(n²) | O(n²) | ✓ | O(n²) |
| **삽입 정렬** | O(n) | O(n²) | O(n²) | ✓ | O(n²) |
| **퀵 정렬** | O(n log n) | O(n log n) | O(n²) | ✗ | O(n log n) |
| **병합 정렬** | O(n log n) | O(n log n) | O(n log n) | ✓ | O(n log n) |

<br>

> 💡 **선택 정렬**은 교환 횟수가 적어 메모리 쓰기 비용이 큰 환경(예: EEPROM)에서 유용하다. 하지만 대부분의 경우 삽입 정렬, 퀵 정렬, 병합 정렬이 더 효율적이다.