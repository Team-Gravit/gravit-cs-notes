## 위상 정렬(Topological Sort)

**순서가 정해져 있는 일련의 작업을 차례대로 수행해야 할 때** 사용하는 정렬 알고리즘이다. **사이클이 없는 방향 그래프**(DAG) 에서만 가능하다.

<br>

### 1. 특징

- **DAG**(Directed Acyclic Graph) 에서만 수행 가능함
- **진입 차수**(Indegree) 개념을 사용함
- 여러 개의 해답이 존재할 수 있음
- 큐를 이용한 **BFS 방식**(Kahn's Algorithm) 과 **DFS 방식** 두 가지 구현 방법이 존재함
- 시간 복잡도: **O(V + E)** (V: 정점 수, E: 간선 수)
- **순환 구조 탐지** 가능함

<br>

### 2. 핵심 개념

**DAG (Directed Acyclic Graph)**

사이클이 없는 방향 그래프를 의미한다.

```
사이클이 없는 그래프 (DAG) → 위상 정렬 가능 ✓
사이클이 있는 그래프 → 위상 정렬 불가능 ✗
무방향 그래프 → 위상 정렬 불가능 ✗
```

<br>

**진입 차수(Indegree)와 진출 차수(Outdegree)**

- **진입 차수**: 특정 노드로 들어오는 간선의 개수
- **진출 차수**: 특정 노드에서 나가는 간선의 개수

<br>

<img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/algorithm/unit12/image1.png" width="100%">

<br>

### 3. 정렬 과정(Kahn's Algorithm)

**진입 차수가 0인 모든 노드**를 큐에 삽입한다. 큐가 빌 때까지 다음을 반복한다.

큐에서 노드를 꺼내 결과에 추가하고, 해당 노드에서 나가는 **간선을 제거**한다(연결된 노드의 **진입 차수 감소**). 새롭게 **진입 차수가 0이 된 노드**를 큐에 삽입한다.

<br>

### 4. 정렬 예시

<img src="https://raw.githubusercontent.com/Team-Gravit/gravit-images/main/algorithm/unit12/image2.png" width="100%">

<br>

**초기 진입 차수**

```
노드 1: 0, 노드 2: 1, 노드 3: 1, 노드 4: 2
노드 5: 1, 노드 6: 2, 노드 7: 1
```

<br>

**단계별 진행**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[Step 0] 진입 차수가 0인 노드 1을 큐에 삽입
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
큐: [1], 결과: []

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[Step 1] 노드 1 처리
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
노드 1 제거 → 노드 2, 5의 진입 차수 감소 (0이 됨)
큐: [2, 5], 결과: [1]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[Step 2] 노드 2 처리
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
노드 2 제거 → 노드 3의 진입 차수 0, 노드 6은 1
큐: [5, 3], 결과: [1, 2]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[Step 3] 노드 5 처리
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
노드 5 제거 → 노드 6의 진입 차수 0
큐: [3, 6], 결과: [1, 2, 5]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[Step 4] 노드 3 처리
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
노드 3 제거 → 노드 4의 진입 차수 1
큐: [6], 결과: [1, 2, 5, 3]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[Step 5] 노드 6 처리
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
노드 6 제거 → 노드 4의 진입 차수 0
큐: [4], 결과: [1, 2, 5, 3, 6]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[Step 6] 노드 4 처리
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
노드 4 제거 → 노드 7의 진입 차수 0
큐: [7], 결과: [1, 2, 5, 3, 6, 4]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[Step 7] 노드 7 처리
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
큐: [], 결과: [1, 2, 5, 3, 6, 4, 7] ← 최종 결과!

```

<br>

### 5. BFS를 이용한 구현

```python
from collections import deque

def topological_sort(graph, n):
    indegree = [0] * (n + 1)

    # 진입 차수 계산
    for i in range(1, n + 1):
        for node in graph[i]:
            indegree[node] += 1

    # 진입 차수가 0인 노드를 큐에 삽입
    queue = deque()
    for i in range(1, n + 1):
        if indegree[i] == 0:
            queue.append(i)

    result = []

    while queue:
        now = queue.popleft()
        result.append(now)

        # 연결된 노드들의 진입 차수 감소
        for next_node in graph[now]:
            indegree[next_node] -= 1
            if indegree[next_node] == 0:
                queue.append(next_node)

    # 사이클 존재 여부 확인
    if len(result) != n:
        return []  # 사이클 존재

    return result
```

<br>

### 6. DFS를 이용한 구현

**알고리즘 단계**

모든 노드에 대해 방문하지 않았다면 **DFS**를 수행한다. DFS 수행 중 현재 노드를 **방문 처리**하고, 인접한 노드 중 방문하지 않은 노드에 대해 **재귀적으로 DFS**를 수행한다. 더 이상 방문할 노드가 없으면 **스택에 현재 노드**를 추가한다. 스택을 **역순으로 pop**하여 결과를 생성한다.

```python
# 스택 사용
def topological_sort_dfs(graph, n):
    visited = [False] * (n + 1)
    stack = []

    def dfs(node):
        visited[node] = True

        for next_node in graph[node]:
            if not visited[next_node]:
                dfs(next_node)

        stack.append(node)

    # 모든 노드에 대해 DFS 수행
    for i in range(1, n + 1):
        if not visited[i]:
            dfs(i)

    return stack[::-1]
```

<br>

### 7. 시간 복잡도

| **방법**     | **시간 복잡도** | **공간 복잡도** |
| ------------ | --------------- | --------------- |
| **BFS 방식** | O(V + E)        | O(V)            |
| **DFS 방식** | O(V + E)        | O(V)            |

**시간 복잡도 분석**

모든 정점 확인에 **O(V)**, 모든 간선 확인(진입 차수 감소)에 O(E)가 소요되어 전체 O(V + E)이다.

<br>

### 8. 사이클 탐지

위상 정렬을 수행하면서 사이클 존재 여부를 확인할 수 있다.

```python
def has_cycle(graph, n):
    result = topological_sort(graph, n)

    # 모든 노드를 방문하지 못했다면 사이클 존재
    if len(result) != n:
        return True
    return False
```

<br>

**사이클이 있으면 위상 정렬이 불가능한 이유**

```
예시: 1 → 2 → 3 → 1 (사이클)

노드 1의 진입 차수: 1 (3→1)
노드 2의 진입 차수: 1 (1→2)
노드 3의 진입 차수: 1 (2→3)

→ 진입 차수가 0인 노드가 없음
→ 큐가 비어있어 시작 불가
→ 사이클 존재 판정
```

<br>

### 9. 답이 여러 개인 경우

한 단계에서 **진입 차수가 0인 노드가 여러 개**면 여러 가지 해답이 존재한다.

```
그래프: 1 → 2, 3 → 4

가능한 답:
[1, 3, 2, 4]
[1, 2, 3, 4]
[3, 1, 4, 2]
[3, 4, 1, 2]
```

<br>

### 10. 위상 정렬의 장점

- **선형 시간 복잡도** O(V + E)로 효율적
- **의존성 해결**: 선후 관계가 있는 작업 순서 결정
- **사이클 탐지** 가능

<br>

### 11. 위상 정렬의 단점

- **DAG에만 적용** 가능함
- **유일한 답을 보장하지 않음**
- 그래프 변경 시 **처음부터 다시 계산** 필요함

<br>

### 12. 활용 사례

- 선수과목 순서 결정
- 작업 스케줄링
- 빌드 시스템 의존성 해결
- 컴파일러 모듈 컴파일 순서
