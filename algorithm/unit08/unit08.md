## 합병 정렬(Merge Sort)

합병 정렬은 **분할 정복(Divide and Conquer)** 방식을 사용하여, 배열을 **절반씩 나누어 정렬**한 후 **합병하며 정렬**하는 알고리즘이다. 모든 경우에 **O(n log n)** 의 안정적인 성능을 보이며, **안정 정렬**(Stable Sort)에 속한다. **재귀적 구조**로 구현되며, 추가 메모리가 필요하다.

<br>

### 1. 특징

- **분할 정복** 알고리즘의 대표적인 예시
- **재귀적 구조**로 문제를 해결
- 배열을 **절반씩 분할**하여 크기 1이 될 때까지 나눔
- 정렬된 부분 배열들을 **합병**하며 전체 정렬 완성
- **안정 정렬**(Stable Sort) - 동일한 값의 순서 유지
- 모든 경우에 **O(n log n)** 시간 복잡도 보장

<br>

### 2. 정렬 과정

**1단계: 분할(Divide)**

배열을 같은 크기의 2개 부분 배열로 분할한다. 배열의 크기가 1이 될 때까지 반복한다.

<br>

**2단계: 정복(Conquer)**

각 부분 배열을 재귀적으로 정렬한다. 크기가 1인 배열은 이미 정렬된 것으로 간주한다.

<br>

**3단계: 결합(Combine)**

정렬된 2개의 부분 배열을 하나의 정렬된 배열로 합병한다. 이 단계에서 실제 정렬이 이루어진다.

<br>

### 3. 정렬 과정 예시

**분할 단계**

배열을 절반씩 나누어 크기가 1이 될 때까지 분할한다.

![image1.png](image1.png)

<br>

**합병 단계 (1회차)**

크기 1인 정렬된 배열들을 합병하여 크기 2인 정렬된 배열로 만든다.

![image2.png](image2.png)

<br>

**합병 단계 (2회차)**

크기 2인 정렬된 배열들을 합병하여 크기 4인 정렬된 배열로 만든다.

![image3.png](image3.png)

<br>

**합병 단계 (3회차)**

크기 4인 정렬된 배열들을 합병하여 최종 정렬된 배열을 완성한다.

![image4.png](image4.png)

<br>

### 4. 구현 코드

합병 정렬을 코드로 구현하면 다음과 같다.

```python
def merge(arr, left, mid, right):

    i = left  # 왼쪽 부분 배열의 인덱스
    j = mid + 1  # 오른쪽 부분 배열의 인덱스
    k = left  # 결과 배열의 인덱스
    
    # 두 부분 배열을 비교하며 합병
    while i <= mid and j <= right:
        if arr[i] <= arr[j]:
            sorted_arr[k] = arr[i]
            i += 1
        else:
            sorted_arr[k] = arr[j]
            j += 1
        k += 1
    
    # 왼쪽 배열에 남은 요소 복사
    while i <= mid:
        sorted_arr[k] = arr[i]
        i += 1
        k += 1
    
    # 오른쪽 배열에 남은 요소 복사
    while j <= right:
        sorted_arr[k] = arr[j]
        j += 1
        k += 1
    
    # 정렬된 배열을 원본 배열에 복사
    for l in range(left, right + 1):
        arr[l] = sorted_arr[l]

def merge_sort(arr, left, right):

    if left < right:
        mid = (left + right) // 2  # 분할 (Divide)
        
        merge_sort(arr, left, mid)  # 왼쪽 절반 정렬
        merge_sort(arr, mid + 1, right)  # 오른쪽 절반 정렬
        
        # 결합 (Combine)
        merge(arr, left, mid, right)  # 두 부분 배열 합병
```

<br>

### 5. 시간 복잡도

| **케이스** | **시간 복잡도** | **설명** |
| --- | --- | --- |
| **최선(Best)** | O(n log n) | 이미 정렬된 경우에도 분할/합병 수행 |
| **평균(Average)** | O(n log n) | 일반적인 경우 |
| **최악(Worst)** | O(n log n) | 역순으로 정렬된 경우도 동일 |

<br>

**시간 복잡도 계산**

- **분할 단계**: 배열을 절반씩 나누므로 깊이는 **log₂n**
- **합병 단계**: 각 단계에서 모든 원소를 비교/이동하므로 **n**번 연산
- **전체**: O(n) × O(log n) = **O(n log n)**

<br>

**공간 복잡도**

- **O(n)**: 합병 과정에서 임시 배열 필요
- 배열 크기만큼의 추가 메모리 사용

❗️**모든 경우에 O(n log n) 시간 복잡도가 보장**되어 성능 예측이 쉽다.

<br>

### 6-1. 합병 정렬의 장점

- **안정적인 시간 복잡도** - 모든 경우 O(n log n) 보장
- **안정 정렬**(Stable Sort) - 동일한 값의 순서 유지
- **데이터 분포에 영향을 덜 받음** - 입력 데이터와 무관하게 일정한 성능
- **연결 리스트**로 구현 시 효율적 (포인터 조작만으로 정렬 가능)
- 대용량 데이터 정렬에 적합

<br>

### 6-2. 합병 정렬의 단점

- **추가 메모리 필요** - O(n)의 공간 복잡도
- **제자리 정렬**(in-place sorting)이 아님
- 작은 데이터에서는 **삽입 정렬**보다 느릴 수 있음

<br>

### 7. 분할 정복(Divide and Conquer)

합병 정렬은 분할 정복 전략의 대표적인 예시이다.

**분할 정복의 3단계**

1. **분할(Divide)**: 문제를 작은 문제로 나눔
2. **정복(Conquer)**: 작은 문제를 재귀적으로 해결
3. **결합(Combine)**: 작은 문제의 해를 합쳐 원래 문제 해결

<br>

### 8. 다른 정렬 알고리즘과 비교

| **정렬 알고리즘** | **최선** | **평균** | **최악** | **안정성** | **공간** |
| --- | --- | --- | --- | --- | --- |
| **합병 정렬** | **O(n log n)** | **O(n log n)** | **O(n log n)** | **✓** | **O(n)** |
| **퀵 정렬** | O(n log n) | O(n log n) | O(n²) | ✗ | O(log n) |
| **힙 정렬** | O(n log n) | O(n log n) | O(n log n) | ✗ | O(1) |
| **삽입 정렬** | O(n) | O(n²) | O(n²) | ✓ | O(1) |
| **버블 정렬** | O(n²) | O(n²) | O(n²) | ✓ | O(1) |

<br>

> 💡 합병 정렬은 안정성과 예측 가능한 성능이 중요한 경우에 적합하다. Python의 Timsort와 Java의 정렬은 합병 정렬을 기반으로 한다. 하지만 일반적인 경우 퀵 정렬이 더 빠른 경향이 있다.
