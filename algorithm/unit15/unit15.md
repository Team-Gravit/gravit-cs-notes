## 다이내믹 프로그래밍(Dynamic Programming)

**다이내믹 프로그래밍**은 큰 문제를 작은 부분 문제로 쪼개고, 각 부분 문제의 해를 저장해두었다가 재사용하면서 전체 문제의 최적해를 구하는 알고리즘 설계 기법이다.

<br>

### 1. 핵심 개념

**중복 계산 제거**

- 같은 부분 문제를 여러 번 풀지 않고 한 번 계산한 결과를 dp 테이블(배열)에 저장해 재사용함

<br>

**최적해를 단계적으로 구성**

- 작은 문제의 최적해를 이용해 점점 더 큰 문제의 최적해를 만들어감
- 그리디처럼 지금 최선을 고르는 것이 아니라 **가능한 경우를 모두 고려**함
- 항상 최적해를 보장하지만 메모리와 시간이 더 소요됨

<br>

### 2. DP 적용 조건

**최적 부분 구조(Optimal Substructure)**

- 큰 문제의 최적해가 **작은 부분 문제들의 최적해로부터 구성**될 수 있는 구조
- 예시: `F(n) = F(n-1) + F(n-2)` (피보나치)

<br>

**부분 문제의 중복(Overlapping Subproblems)**

- 문제를 풀다 보면 **같은 부분 문제를 여러 번** 다시 풀어야 하는 구조
- 예시: 재귀 피보나치에서 `F(2)`, `F(3)` 등이 계속 반복 호출됨

<br>

### 3. DP 문제 접근 단계

1. **상태 정의**: `dp[i]`가 무엇인지 정의함
    - 예시: `dp[i] = i번째 피보나치 수`

<br>

2. **점화식 세우기**: 상태 전이 관계를 정의함
    - 예시: `dp[i] = dp[i-1] + dp[i-2]`

<br>

3. **초기값 설정**: Base Case를 설정함
    - 예시: `dp[0] = 0, dp[1] = 1`

<br>

4. **계산 순서 정하기**: Top-Down 또는 Bottom-Up 방식 선택

<br>

### 4. Bottom-Up vs Top-Down

**Bottom-Up 방식(Tabulation)**

- 아래에서부터 계산을 수행하고 누적시켜 전체 문제를 해결함
- `dp[0]`에서 시작해 점화식을 통해 `dp[n]`까지 값을 전이시킴
- 테이블에 저장된 값에 직접 접근하여 재활용함

<br>

**Top-Down 방식(Memoization)**

- `dp[n]`의 값을 찾기 위해 위에서부터 호출을 시작함
- `dp[0]`까지 내려간 다음 결과값을 재귀를 통해 전이시켜 재활용함
- 메모리에 저장된 내역을 꺼내서 사용함

<br>

### 5. 예시: 피보나치 수열

**점화식**

- `fib(0) = 0`
- `fib(1) = 1`
- `fib(n) = fib(n-1) + fib(n-2)` (n≥2)

<br>

**재귀 트리 구조**

`fib(5)`를 계산할 때:

- `fib(5) = fib(4) + fib(3)`
- `fib(4) = fib(3) + fib(2)`
- `fib(3) = fib(2) + fib(1)`
- `fib(2) = fib(1) + fib(0)`

<br>

**실제 계산값**

- `fib(2) = 1 + 0 = 1`
- `fib(3) = 1 + 1 = 2`
- `fib(4) = 2 + 1 = 3`
- `fib(5) = 3 + 2 = 5`

<br>

**DP 포인트**

- `fib(3)`이 2번 등장, `fib(2)`는 3번 등장
- 같은 부분 문제를 여러 번 계산함
- 한 번 계산한 값을 저장해두고 재사용하는 것이 **메모이제이션**

<br>

### 6. 예시: 거스름돈 문제

**문제**

동전이 **16원, 5원, 1원**이고 각 동전은 무한히 많다. **20원**을 거슬러 줄 때 필요한 **동전 개수의 최소값**을 구하라.

<br>

**그리디 전략의 한계**

- 그리디: 16원 1개 + 1원 4개 → **총 5개**
- 실제 최적: 5원 4개 → **총 4개**

<br>

**DP 접근**

**상태 정의**: `C[j] = j원을 거슬러 줄 때 사용되는 동전 개수의 최소값`

**점화식**

```
C[j] = min(C[j-1] + 1, C[j-5] + 1, C[j-16] + 1)
```

<br>

마지막에 어떤 동전을 쓰느냐에 따라 경우가 나뉨:

- **1원** 사용: `C[j-1] + 1`
- **5원** 사용: `C[j-5] + 1`
- **16원** 사용: `C[j-16] + 1`

<br>

<img src="image1.png" width="100%">

<br>

<br>

**계산 과정**

**기저값**

- `C[0] = 0`
- `C[1] = 1`

**점진적 계산**

- `C[2] = C[1] + 1 = 2`
- `C[3] = C[2] + 1 = 3`
- `C[4] = C[3] + 1 = 4`
- `C[5] = min(C[4] + 1, C[0] + 1) = min(5, 1) = 1`
- `C[16] = min(C[15] + 1, C[11] + 1, C[0] + 1) = 1`
- `C[20] = min(C[19] + 1, C[15] + 1, C[4] + 1) = 4`

<br>

**결과**: **C[20] = 4** (5원 동전 4개)

<br>

<img src="image2.png" width="100%">