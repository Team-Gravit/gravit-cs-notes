## 트랜잭션(Transaction)

**데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 논리적 단위**다. 논리적인 이유로 여러 SQL문을 단일 작업으로 묶어 **분리 불가능한 단위**로 만든 것이다.

<br>

### 1. 트랜잭션의 특징

**작업의 완전성 보장**

- 트랜잭션 내 SQL문은 모두 성공하면 **커밋(Commit)**되고, 하나라도 실패하면 전체가 **롤백(Rollback)**됨
- 일부만 성공해서 DB에 반영되는 일은 발생하지 않음

<br>

**상태 변경**

- SELECT, INSERT, UPDATE, DELETE 같은 조작어를 사용하여 데이터베이스 상태를 변경함

<br>

### 2. 트랜잭션 연산

**커밋(Commit)**

- 트랜잭션이 성공적으로 수행되었음을 선언하는 연산
- 수행 결과를 최종적으로 DB에 반영함

<br>

**롤백(Rollback)**

- 트랜잭션 수행이 실패했음을 선언하고 작업을 취소하는 연산
- DB를 트랜잭션 수행 전의 일관된 상태로 되돌림

<br>

### 3. 트랜잭션의 상태

**활동(Active)**

- 트랜잭션이 실행 중이며 동작 중인 상태

<br>

**부분 완료(Partially Committed)**

- 트랜잭션의 마지막 연산까지 실행했으나 Commit 연산을 실행하기 직전의 상태
- Commit 명령이 도착한 상태

<br>

**완료(Committed)**

- 트랜잭션이 성공적으로 완료된 상태
- Commit을 정상적으로 완료한 상태

<br>

**실패(Failed)**

- 더 이상 정상적으로 진행될 수 없는 상태

<br>

**철회(Aborted)**

- 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태
- Rollback 연산을 실행한 상태

<br>

### 4. 트랜잭션 사용 시 주의점

**범위 최소화**

- 트랜잭션은 꼭 필요한 최소한의 코드에만 적용해야 함
- DB 커넥션은 개수가 제한적이므로 각 단위 프로그램이 커넥션을 소유하는 시간이 길어지면 가용 커넥션이 부족해짐

<br>

---

## ACID 특성

트랜잭션이 안전하게 수행되기 위해 보장해야 하는 **4가지 속성**이다. 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)의 앞글자를 딴 규칙이다.

<br>

### 1. 원자성(Atomicity)

**All or Nothing**

- 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장함
- 트랜잭션이 DB에 모두 반영되거나 전혀 반영되지 않아야 함

<br>

**구현 방법**

- 수행 중인 트랜잭션의 변경 내역을 유지하면서 이전에 커밋된 상태를 **롤백 세그먼트(Rollback Segment)**에 저장함
- 오류 발생 시 롤백 세그먼트에 저장된 상태로 되돌림

<br>

**세이브포인트(Save Point)**

- 트랜잭션 중간에 저장 지점을 지정하여 전체가 아닌 특정 부분까지만 롤백 가능
- `SAVEPOINT 이름` 설정 후 `ROLLBACK TO SAVEPOINT 이름` 실행

<br>

### 2. 일관성(Consistency)

**제약 조건 만족**

- 트랜잭션 작업 처리 결과는 항상 일관성이 있어야 함
- 트랜잭션 수행 전후에 데이터 모델의 모든 제약 조건을 만족해야 함

<br>

**구현 방법**

- **트리거(Trigger)**를 통해 보장함
- 특정 이벤트 발생 시 자동으로 실행되는 프로그램으로 데이터베이스의 일관성을 유지함

<br>

**DBMS의 역할**

- 커밋 전에 제약 조건 위반 여부를 확인함
- 애플리케이션 관점에서의 일관성은 개발자가 챙겨야 함

<br>

### 3. 격리성(Isolation)

**독립적 실행**

- 여러 트랜잭션이 동시에 실행될 때도 혼자 실행되는 것처럼 동작해야 함
- 동시에 실행되는 트랜잭션들은 서로 영향을 주지 않고 독립적으로 실행되는 것처럼 보여야 함

<br>

**구현 방법**

- **Lock & Unlock** 기법 사용
- 작업 중인 영역에 Lock을 걸어 다른 트랜잭션의 접근을 막고, 작업 완료 후 Unlock하여 접근을 허용함

<br>

**격리 수준(Isolation Level)**

- DBMS는 여러 종류의 격리 수준을 제공함
- 개발자는 상황에 맞는 격리 수준을 설정할 수 있음

<br>

### 4. 지속성(Durability)

**영구적 저장**

- 커밋된 트랜잭션의 결과는 데이터베이스에 영구적으로 저장되어야 함
- 비휘발성 메모리(HDD, SSD)에 저장됨을 의미함

<br>

**시스템 장애 대응**

- DB 시스템에 문제가 생겨도 커밋된 결과는 계속 남아있어야 함
- DBMS가 보장하는 속성임

<br>

---

## 트랜잭션 격리 수준(Isolation Level)

**동시에 여러 트랜잭션이 처리될 때 트랜잭션끼리 얼마나 서로 고립되어 있는지**를 나타낸다. 특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할지를 결정한다.

<br>

### 1. 격리 수준의 필요성

**성능과 안정성의 균형**

- Locking으로 모든 트랜잭션을 순서대로 처리하면 안전하지만 성능이 떨어짐
- Locking 범위를 줄이면 성능은 높아지지만 잘못된 값이 처리될 위험이 있음
- 최대한 효율적인 Locking 방법이 필요함

<br>

### 2. 격리 수준의 종류

격리 수준은 아래로 갈수록 트랜잭션 간 고립 정도가 높아지며 성능이 떨어진다.

<br>

**READ UNCOMMITTED (레벨 0)**

- 다른 트랜잭션의 커밋되지 않은 변경 내용을 읽을 수 있음
- **Dirty Read** 현상 발생
- 정합성 문제가 많아 사용을 권장하지 않음

<br>

**READ COMMITTED (레벨 1)**

- 커밋된 데이터만 읽을 수 있음
- 실제 테이블이 아닌 **Undo 영역의 백업 레코드**에서 값을 가져옴
- Dirty Read는 발생하지 않으나 **Non-Repeatable Read** 현상 발생
- Oracle, PostgreSQL의 기본 격리 수준

<br>

**REPEATABLE READ (레벨 2)**

- 트랜잭션 시작 시점의 데이터를 일관되게 읽음
- Undo 공간에 백업해두고 실제 레코드 값을 변경함
- **트랜잭션 ID**를 부여하여 자신보다 작은 ID에서 변경한 것만 읽음
- **Phantom Read** 현상 발생 가능
- MySQL(InnoDB)의 기본 격리 수준

<br>

**SERIALIZABLE (레벨 3)**

- 가장 엄격한 격리 수준
- 완벽한 읽기 일관성 모드 제공
- 다른 사용자는 트랜잭션 영역의 데이터에 대한 수정 및 입력 불가능
- 동시 처리 성능이 가장 낮음
- DB에서 거의 사용하지 않음

<br>

### 3. 격리 수준별 부정합 문제

**Dirty Read (더티 리드)**

- 커밋되지 않은 데이터를 읽어들이는 현상
- 트랜잭션 종료 후 더 이상 존재하지 않거나 롤백되었거나 위치가 바뀐 데이터를 읽음
- READ UNCOMMITTED에서 발생

<br>

**Non-Repeatable Read (반복 불가능한 읽기)**

- 한 트랜잭션 내에서 같은 쿼리를 두 번 수행할 때 결과가 상이한 현상
- 그 사이에 다른 트랜잭션이 값을 수정하거나 삭제했기 때문
- READ COMMITTED에서 발생

<br>

**Phantom Read (팬텀 리드)**

- 한 트랜잭션 내에서 일정 범위의 레코드를 두 번 이상 읽을 때 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나는 현상
- 다른 트랜잭션에서 수행한 INSERT 작업에 의해 발생
- REPEATABLE READ에서 발생 가능

<br>

### 4. 격리 수준 비교

| 격리 수준            | Dirty Read | Non-Repeatable Read | Phantom Read |
| -------------------- | ---------- | ------------------- | ------------ |
| **READ UNCOMMITTED** | 발생       | 발생                | 발생         |
| **READ COMMITTED**   | -          | 발생                | 발생         |
| **REPEATABLE READ**  | -          | -                   | 발생 가능    |
| **SERIALIZABLE**     | -          | -                   | -            |

<br>

---

## Lock(락)

**여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 하나의 커넥션만 변경할 수 있게 해주는 기능**이다. 동시성을 제어하기 위한 메커니즘이다.

<br>

### 1. Lock의 종류

**공유 Lock (Shared Lock, Read Lock, S-Lock)**

- 데이터를 변경하지 않는 **읽기 작업**을 위한 잠금
- 다른 세션에서 해당 데이터에 **공유 Lock을 걸고 접근 가능**
- 다른 세션에서 해당 데이터에 **배타 Lock을 걸고 접근 불가능**
- "데이터 읽는 동안 다른 세션도 읽을 수 있지만 변경은 불가능"

<br>

**배타 Lock (Exclusive Lock, Write Lock, X-Lock)**

- 데이터를 변경하는 **쓰기 작업**을 위한 잠금
- 다른 세션에서 해당 데이터에 **공유 Lock을 걸고 접근 불가능**
- 다른 세션에서 해당 데이터에 **배타 Lock을 걸고 접근 불가능**
- "데이터 쓰는 동안 다른 세션은 읽기도 쓰기도 불가능"

<br>

### 2. 블로킹(Blocking)

**정의**

- Lock 간의 경합이 발생해서 특정 트랜잭션이 작업을 진행하지 못하고 대기하는 상태

<br>

**발생 조건**

- 특정 데이터에 공유 Lock 설정된 상태에서 배타 Lock 설정 시도
- 특정 데이터에 배타 Lock 설정된 상태에서 공유 Lock 설정 시도
- 특정 데이터에 배타 Lock 설정된 상태에서 배타 Lock 설정 시도

<br>

**해결 방법**

- Lock 설정한 트랜잭션이 커밋 또는 롤백되어야 함
- Lock Timeout 시간이 경과하면 자동으로 롤백됨

<br>

**블로킹 최소화 방안**

- 트랜잭션 작업 단위를 최대한 적게 구성함
- 동일한 데이터를 동시에 변경하는 작업을 하지 않도록 설계함
- 트랜잭션이 활발한 시간대에는 대용량 데이터 작업을 지양함

<br>

### 3. 데드락(Dead Lock)

**정의**

- 두 트랜잭션 모두가 블로킹 상태에 진입하여 서로의 블로킹을 해결할 수 없는 상태
- 두 개 이상의 트랜잭션이 특정 자원의 잠금을 획득한 채 다른 트랜잭션이 소유한 잠금을 요구하면 무한 대기 상태가 됨

<br>

**발생 과정**

1. 트랜잭션 A가 데이터 X에 Lock 설정
2. 트랜잭션 B가 데이터 Y에 Lock 설정
3. 트랜잭션 A가 데이터 Y에 Lock 설정 시도 → 블로킹
4. 트랜잭션 B가 데이터 X에 Lock 설정 시도 → 블로킹
5. 서로의 트랜잭션 종료를 기다리므로 영원히 해결 불가능

<br>

**해결 방법**

- **데드락 감지**: DBMS가 자동으로 감지하여 하나의 트랜잭션을 롤백함
- **데드락 방지**: 트랜잭션들이 동일한 순서로 테이블에 접근하도록 설계함

<br>

**데드락 빈도 감소 방법**

- 트랜잭션을 자주 커밋함
- 정해진 순서로 테이블에 접근함
- 읽기 잠금 획득(SELECT FOR UPDATE)의 사용을 피함
- 한 테이블의 복수 행을 복수 연결에서 순서 없이 갱신하면 교착상태 발생 위험이 높으므로 테이블 단위 잠금을 획득함
