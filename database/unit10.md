## 페이징(Pagination)

**페이징**은 대량의 데이터를 일정 단위로 나누어 조회하는 기법이다. 전체 데이터를 한 번에 조회하지 않고 필요한 만큼만 가져와 성능과 사용자 경험을 개선한다.

<br>

### 1. 오프셋 기반 페이징(OFFSET Pagination)

**LIMIT**과 **OFFSET**을 사용하여 특정 범위의 데이터를 조회한다.

<br>

**기본 구조**

```sql
SELECT column
FROM table
ORDER BY id
LIMIT {페이지당 개수} OFFSET {건너뛸 개수};
```

<br>

**예시**

```sql
-- 1페이지 (1~10번)
SELECT * FROM posts
ORDER BY id
LIMIT 10 OFFSET 0;

-- 2페이지 (11~20번)
SELECT * FROM posts
ORDER BY id
LIMIT 10 OFFSET 10;

-- 3페이지 (21~30번)
SELECT * FROM posts
ORDER BY id
LIMIT 10 OFFSET 20;
```

<br>

**계산 공식**

```
OFFSET = (페이지 번호 - 1) × 페이지당 개수
```

<br>

### 2. 오프셋 페이징의 문제점

**성능 저하**

- 데이터가 많을수록 OFFSET이 커지면서 성능 급격히 저하
- OFFSET 1000000이면 100만 개 행을 읽고 버림

<br>

**데이터 일관성 문제**

- 페이지 조회 중 데이터 삽입/삭제 시 중복 또는 누락 발생
- 예시: 1페이지 조회 후 새 데이터 삽입 시 2페이지에 중복 데이터 포함

<br>

**메모리 부담**

- OFFSET 값만큼의 데이터를 메모리에 로드 후 버림
- 대용량 데이터에서 비효율적

<br>

### 3. 키셋 기반 페이징(Keyset Pagination)

마지막 조회 데이터의 키 값을 기준으로 다음 데이터를 조회한다. **WHERE** 조건으로 키 값보다 큰/작은 데이터만 선택하므로 성능이 일정하다.

<br>

**기본 구조**

```sql
-- 첫 페이지
SELECT * FROM posts
ORDER BY id DESC
LIMIT 10;

-- 다음 페이지 (마지막 id가 100이었다면)
SELECT * FROM posts
WHERE id < 100
ORDER BY id DESC
LIMIT 10;
```

<br>

**동작 방식**

```
1페이지: id < ∞, LIMIT 10 → 결과: id 110~101
2페이지: id < 101, LIMIT 10 → 결과: id 100~91
3페이지: id < 91, LIMIT 10 → 결과: id 90~81
```

<br>

### 4. 키셋 페이징의 장점

**일정한 성능**

- OFFSET 없이 WHERE 조건으로 필터링
- 데이터 양과 무관하게 성능 유지

<br>

**데이터 일관성**

- 조회 기준이 절대값(키)이므로 중복/누락 최소화
- 실시간 데이터 변경에도 안정적

<br>

**인덱스 활용**

- 키 컬럼에 인덱스가 있으면 매우 빠른 조회
- 인덱스 스캔만으로 처리 가능

<br>

### 5. 키셋 페이징의 단점

**특정 페이지 이동 불가**

- 이전 페이지의 마지막 키를 알아야 다음 페이지 조회 가능
- 페이지 번호 기반 UI 구현 어려움

<br>

**복잡한 정렬 처리**

- 여러 컬럼 정렬 시 WHERE 조건 복잡해짐
- 복합 키 처리가 까다로움

<br>

**역방향 탐색 제한**

- 이전 페이지로 이동 시 별도 쿼리 필요
- 양방향 페이징 구현이 복잡함

<br>

### 6. 복합 키 기반 키셋 페이징

여러 컬럼으로 정렬 시 복합 조건을 사용한다.

<br>

**예시: created_at + id 정렬**

```sql
-- 첫 페이지
SELECT * FROM posts
ORDER BY created_at DESC, id DESC
LIMIT 10;

-- 다음 페이지 (마지막 created_at: 2024-01-15, id: 100)
SELECT * FROM posts
WHERE (created_at, id) < ('2024-01-15', 100)
ORDER BY created_at DESC, id DESC
LIMIT 10;
```

<br>

**MySQL 튜플 비교**

```sql
-- (a, b) < (x, y)는 다음과 같음:
-- a < x OR (a = x AND b < y)
WHERE (created_at, id) < ('2024-01-15', 100)

-- 실제 의미:
WHERE created_at < '2024-01-15' OR (created_at = '2024-01-15' AND id < 100)
```

<br>

### 7. 페이징 방식 선택 기준

| 특성              | 오프셋 페이징                   | 키셋 페이징                |
| ----------------- | ------------------------------- | -------------------------- |
| **성능**          | 데이터 많을수록 느림            | 일정한 속도 유지           |
| **구현 난이도**   | 쉬움                            | 복잡함                     |
| **페이지 이동**   | 자유로움                        | 순차적만 가능              |
| **데이터 일관성** | 낮음                            | 높음                       |
| **적합한 경우**   | 소규모 데이터, 페이지 번호 필요 | 대규모 데이터, 무한 스크롤 |

<br>

### 8. 실무 페이징 패턴

**무한 스크롤**

- 키셋 페이징 사용
- 모바일 앱, SNS 피드에 적합

<br>

**페이지 번호 네비게이션**

- 오프셋 페이징 사용
- 관리자 페이지, 검색 결과에 적합

<br>

**하이브리드 방식**

- 초기 몇 페이지는 오프셋 페이징
- 이후 페이지는 키셋 페이징으로 전환
- 사용자 경험과 성능 모두 고려
